<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java笔记</title>
      <link href="/2024/02/04/java%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/04/java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java学习笔记"><a href="#Java学习笔记" class="headerlink" title="Java学习笔记"></a>Java学习笔记</h1><h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><h3 id="1、遍历数组"><a href="#1、遍历数组" class="headerlink" title="1、遍历数组"></a>1、遍历数组</h3><ul><li>法1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> b[][]=&#123;&#123;<span class="number">1</span>&#125;.&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;<span class="comment">//定义二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;b.length;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;b[k].length;c++)&#123;</span><br><span class="line">                System.out.print(b[k][c]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>法2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">deo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[][]= &#123;&#123;<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中的元素是：&quot;</span>);</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;<span class="comment">//外层循环计数器变量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x[]:arr) &#123; <span class="comment">//外层循环变量为一维数组</span></span><br><span class="line">i++;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> e:x) &#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(i==arr.length&amp;&amp;j==x.length) &#123;</span><br><span class="line">System.out.print(e);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.print(e+<span class="string">&quot;、&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、填充替换数组元素"><a href="#2、填充替换数组元素" class="headerlink" title="2、填充替换数组元素"></a>2、填充替换数组元素</h3><ul><li>fill(int [] arr,int value)；</li><li>1.arr：要进行填充的数组；</li><li>2.value：要存储数组中所有元素的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays; <span class="comment">//导包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">8</span>);<span class="comment">//使用同一个值对数组进行填充</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>fill(int[] arr,int from,int to,int value)；</li><li>1.arr：要进行填充的数组；</li><li>2.from：要使用指定值填充的第一个元素的索引（包括）；</li><li>3.to：要使用指定值填充的最后一个元素的索引（不包括）；</li><li>4.value：要分配给数组指定范围中的每个元素的值.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.fill(arr,<span class="number">1</span>,<span class="number">3</span>, <span class="number">8</span>);<span class="comment">//使用同一个值对数组进行填充</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、对数组进行排序"><a href="#3、对数组进行排序" class="headerlink" title="3、对数组进行排序"></a>3、对数组进行排序</h3><p>Arrays.sort(object)；</p><p>object为需要进行排序的数组名称.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.fill(arr,<span class="number">1</span>,<span class="number">3</span>, <span class="number">8</span>);<span class="comment">//使用同一个值对数组进行填充</span></span><br><span class="line">Arrays.sort(arr);<span class="comment">//从小到大排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">65</span>&#125;;<span class="comment">//创建一个数组</span></span><br><span class="line">     BubbleSort sorter=<span class="keyword">new</span> <span class="title class_">BubbleSort</span>();<span class="comment">//创建冒泡排序类的对象</span></span><br><span class="line">     sorter.sort(arr);<span class="comment">//调用排序方法，对数组进行排序</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> []arr)</span> &#123;<span class="comment">//冒泡排序</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;<span class="comment">//排序趟数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">     <span class="type">int</span> temp=arr[j];</span><br><span class="line">     arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">     arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i:arr) &#123;<span class="comment">//打印输出数组</span></span><br><span class="line">     System.out.print(<span class="string">&quot;&gt;&quot;</span>+i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;<span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[]arr= &#123;<span class="number">43</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">7</span>&#125;;</span><br><span class="line">sort(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line"><span class="comment">//每次排序一趟找出待排序元素中的最大值放到末尾</span></span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=arr.length-i;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[index]) &#123;</span><br><span class="line">index=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换index和arr.length-i的值</span></span><br><span class="line"><span class="type">int</span> temp=arr[arr.length-i];</span><br><span class="line">arr[arr.length-i]=arr[index];</span><br><span class="line">arr[index]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr) &#123;<span class="comment">//打印输出数组</span></span><br><span class="line">System.out.print(<span class="string">&quot;&gt;&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="反转排序"><a href="#反转排序" class="headerlink" title="反转排序"></a>反转排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]= &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>&#125;;</span><br><span class="line">sort(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> []arr)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;原数组元素内容为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;&gt;&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="type">int</span> temp,len=arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++) &#123;</span><br><span class="line"><span class="comment">//交换元素位置   </span></span><br><span class="line">temp=arr[i];</span><br><span class="line">arr[i]=arr[len-i-<span class="number">1</span>];</span><br><span class="line">arr[len-<span class="number">1</span>-i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;新数组元素内容为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;&gt;&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、复制数组"><a href="#4、复制数组" class="headerlink" title="4、复制数组"></a>4、复制数组</h3><p>copyOf(arr,int newlength)；</p><p>arr：要进行复制的数组；</p><p>newlength：int型常量，指复制后的新数组的长度。如果新数组长度大于原数组长度，则用0（null)来填充；</p><p>若小于原数组长度，则会从原数组的第一个元素开始截取至满足新数组长度为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[]=Arrays.copyOf(arr,<span class="number">3</span>);<span class="comment">//复制数组，新数组长度小于原数组</span></span><br><span class="line"><span class="type">int</span> arr3[]=Arrays.copyOf(arr, <span class="number">10</span>);<span class="comment">//复制数组，新数组长度大于原数组，多的部分用0填充</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr2.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr2[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr3.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr3[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>copyOfRange(arr,int from,int to)；</p><p>arr：要复制的数组</p><p>from：指开始复制数组的索引位置(包括）;</p><p>to：指开始复制数组的结束索引位置（不包括）;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[]=Arrays.copyOfRange(arr,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//复制数组</span></span><br><span class="line"><span class="type">int</span> arr3[]=Arrays.copyOfRange(arr,<span class="number">0</span>,<span class="number">10</span>);<span class="comment">//超过部分会用0填充</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr2.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr2[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr3.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+arr3[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、查询数组"><a href="#5、查询数组" class="headerlink" title="5、查询数组"></a>5、查询数组</h3><p>binarySearch(Object[] arr, Object value); &#x2F;&#x2F;返回的是搜素值得索引，否则返回-1或‘  -  ’（插入点）;</p><p>arr：要搜素的数组；</p><p>value：要搜素的值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> index=Arrays.binarySearch(arr, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3的索引位置是：&quot;</span>+index);</span><br><span class="line"><span class="type">int</span> index2=Arrays.binarySearch(arr, <span class="number">11</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;11的索引位置是：&quot;</span>+index2+<span class="string">&quot;(数组中未找到该元素）&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>binarySearch(object[] arr,int from,int to,int value);</p><p>arr：要进行检索的数组；</p><p>from：指定范围检索的开始处索引（包括）;</p><p>to：指定范围检索的结束处索引（不包括）;</p><p>value：要搜素的值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> index=Arrays.binarySearch(arr,<span class="number">0</span>,<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3的索引位置是：&quot;</span>+index);</span><br><span class="line"><span class="type">int</span> index2=Arrays.binarySearch(arr,<span class="number">0</span>,<span class="number">5</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;11的索引位置是：&quot;</span>+index2+<span class="string">&quot;(数组中未找到该元素）&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h2><p>单个字符可以用char类型保存，多个字符组成的文本就需要保存在String对象中。String通常称为字符串，一个String对象最多可以保存2^32-1个字节（占用4GB空间大小）的文本内容。</p><h3 id="1、声明、创建字符串"><a href="#1、声明、创建字符串" class="headerlink" title="1、声明、创建字符串"></a>1、声明、创建字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str;<span class="comment">//声明字符串</span></span><br><span class="line"><span class="comment">//声明的字符串变量必须经过初始化后才能使用，否则编译器会报出&quot;变量未被初始化错误&quot;。</span></span><br><span class="line"><span class="comment">//创建字符串</span></span><br><span class="line"><span class="type">char</span> a[]=&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(a);    <span class="comment">//等价于String s=new String(&quot;good&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[]=[<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;t&#x27;</span>];</span><br><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(a,<span class="number">2</span>,<span class="number">4</span>);<span class="comment">//等价于String s=new String(&quot;udent&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str1;</span><br><span class="line">str1=<span class="string">&quot;Student&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="2、连接字符串"><a href="#2、连接字符串" class="headerlink" title="2、连接字符串"></a>2、连接字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Link</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String str1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;春色绿千里&quot;</span>);</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;马蹄香万家&quot;</span>);</span><br><span class="line">String s=str1+<span class="string">&quot;\n&quot;</span>+str2;</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="type">int</span> booktime=<span class="number">4</span>;</span><br><span class="line"><span class="type">float</span> practice=<span class="number">6.5f</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;我每天花费&quot;</span>+booktime+<span class="string">&quot;小时看书；&quot;</span>+practice+<span class="string">&quot;小时上机训练&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、获取字符串信息"><a href="#3、获取字符串信息" class="headerlink" title="3、获取字符串信息"></a>3、获取字符串信息</h3><ul><li>使用String类的length()方法可以获取声明的字符串对象的长度.</li><li>indexOf(String s)；&#x2F;&#x2F;该方法返回参数字符串s在指定字符串中首次出现的索引位置。若未找到字符串s，则会返回-1.</li><li>lastIndexOf(String str)；&#x2F;&#x2F;该方法返回参数字符串s在指定字符串中最后一次出现的索引位置。若未找到字符串s，则会返回-1.</li><li>charAt(int index)方法可以将指定索引处的字符返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取字符串长度</span></span><br><span class="line">String str=<span class="string">&quot;We are student&quot;</span>;</span><br><span class="line"><span class="type">int</span> size=str.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.字符串查找</span></span><br><span class="line">String str=<span class="string">&quot;We are student&quot;</span>;</span><br><span class="line"><span class="type">int</span> index=str.indexOf(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">int</span> index2=str.lastIndexOf(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取指定索引位置的字符</span></span><br><span class="line">String str=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> mychar=str.chatAt(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="4、字符串操作"><a href="#4、字符串操作" class="headerlink" title="4、字符串操作"></a>4、字符串操作</h3><ul><li>获取子字符串</li></ul><p>substring(int begin)；</p><p>该方法返回的是从指定的索引位置开始截取到该字符串结尾的子串</p><p>substring(int begin,int end)；</p><p>该方法返回的是从字符串某一索引位置开始截取到某一索引位置结束的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取子字符串</span></span><br><span class="line">String sub1=str.substring(<span class="number">2</span>);</span><br><span class="line">String sub2=str.substring(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(sub1);</span><br><span class="line">System.out.println(sub2);</span><br></pre></td></tr></table></figure><ul><li>去除空格</li></ul><p>trim();</p><p>该方法返回字符串的副本，忽略掉前导空格和后导空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.去除空格</span></span><br><span class="line">String s=<span class="string">&quot; Java  学习 &quot;</span>;</span><br><span class="line">System.out.println(s.length());</span><br><span class="line">System.out.println(s.trim().length());</span><br></pre></td></tr></table></figure><ul><li>字符串替换</li></ul><p>replace(target, replacement)；</p><p>该方法可以实现将指定的字符或字符串替换成新的字符或字符串。</p><p>target:要替换的字符或字符串</p><p>replacement:用于替换原来字符串的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.替换字符串</span></span><br><span class="line">String s1=<span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">String s2=s1.replace( <span class="string">&quot;l&quot;</span>,<span class="string">&quot;L&quot;</span>);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure><ul><li>判断字符串的开始与结尾</li></ul><p>startWith(String prefix)；</p><p>该方法判断当前字符串对象的前缀是否为参数指定的字符串。</p><p>prefix是指作为前缀的字符串。</p><p>endWith(String suffix)；</p><p>该方法用于判断当前字符串是否以给定的字符串结束。</p><p>suffix是指作为后缀的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.判断字符串的开始与结束</span></span><br><span class="line">String num1=<span class="string">&quot;22045612&quot;</span>;</span><br><span class="line">String num2=<span class="string">&quot;21304578&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> flag1=num1.startsWith(<span class="string">&quot;22&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> flag2=num2.endsWith(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串num1是以&#x27;22&#x27;开始的吗？&quot;</span>+flag1);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串num2是以&#x27;11&#x27;结束的吗？&quot;</span>+flag2);</span><br></pre></td></tr></table></figure><ul><li>判断字符是否相等</li></ul><p>equals(String str)；</p><p>该方法用于判断两个字符串是否相等，且区分大小写，返回的是boolean类型。</p><p>equalsLgnoreCase(String str)；</p><p>该方法用于判断两个字符串是否相等，忽略字母的大小写，返回的是boolean类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.判断字符串是否相等</span></span><br><span class="line">String sh1=<span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">String sh2=<span class="string">&quot;HElloworld&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> a1=sh1.equals(sh2);<span class="comment">//区分大小写</span></span><br><span class="line"><span class="type">boolean</span> a2=sh1.equalsIgnoreCase(sh2);<span class="comment">//忽略大小写</span></span><br><span class="line">System.out.println(a1);</span><br><span class="line">System.out.println(a2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>按字典序比较两个字符串</li></ul><p>compareTo(String str)；</p><p>该方法按照字典顺序比较两个字符串，若按照字典顺序此String对象位于参数字符串之前则返回一个负整数，位于之后，则返回一个正整数，如果两个字符串相同则返回0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.按字典顺序比较两个字符串</span></span><br><span class="line">String sa1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String sa2=<span class="string">&quot;hallo&quot;</span>;</span><br><span class="line"><span class="type">int</span> compare=sa1.compareTo(sa2);</span><br><span class="line">System.out.println(compare);</span><br></pre></td></tr></table></figure><ul><li>字母大小写转换</li></ul><p>toLowerCase()；</p><p>将字符串中所有大写字母转化为小写字母；</p><p>toUpperCase()；</p><p>将字符串中所有小写字母转化为大写字母</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.字母大小写转换</span></span><br><span class="line">sa1=<span class="string">&quot;heelll&quot;</span>;</span><br><span class="line">String ss=sa1.toUpperCase();</span><br><span class="line">String sss=ss.toLowerCase();</span><br><span class="line">System.out.println(ss);</span><br><span class="line">System.out.println(sss);</span><br></pre></td></tr></table></figure><ul><li>字符串分割</li></ul><p>1.split(String sign)；</p><p>该方法可以将给定的分割符对字符串进行拆分，其中sign为分割字符串的分割符。</p><p>2.split(String sign,int limit)；</p><p>该方法可以根据给定的分割符对字符串进行拆分，并限定拆分的次数，其中sign为分割字符串的分割符，limit为限制的拆分次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.字符串分割</span></span><br><span class="line">str=<span class="string">&quot;192.168.0.1&quot;</span>;</span><br><span class="line">String[]firstArray=str.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">String[]secondArray=str.split(<span class="string">&quot;\\.&quot;</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;str的原值为：[&quot;</span>+str+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;全部分割后的结果为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String a:firstArray) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;[&quot;</span>+a+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.print(<span class="string">&quot;分割两次后的结果为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String a:secondArray) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;[&quot;</span>+a+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><h3 id="5、字符串生成器"><a href="#5、字符串生成器" class="headerlink" title="5、字符串生成器"></a>5、字符串生成器</h3><p>如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费内存空间，而这种操作还不可避免。因此我们可以通过StringBuild类来解决这个问题。</p><p>StringBuilder是一个可变的字符串类，我们可以把它看作一个容器，这里的可变指的是StringBuilder对象中的内容是可变的</p><p><strong>StringBuilder和String的区别：</strong></p><ul><li>StringBuilder：内容是可变的</li><li>String：内容是不变的</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>public StringBuilder()；  创建一个空白可变字符串对象，不含任何内容</p><p>public StringBuilder(String str)；  根据字符串的内容，来创建可变字符串对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//public StringBuilder();创建一个空白可变字符串对象，不含任何内容</span></span><br><span class="line"><span class="comment">//public StringBuilder(String str);根据字符串的内容，来创建可变字符串对象</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;sb:&quot;</span>+sb);</span><br><span class="line">System.out.println(<span class="string">&quot;sb.length():&quot;</span>+sb.length());</span><br><span class="line">StringBuilder sb2=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2);</span><br><span class="line">System.out.println(<span class="string">&quot;sb2.length():&quot;</span>+sb2.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加和反转方法"><a href="#添加和反转方法" class="headerlink" title="添加和反转方法"></a>添加和反转方法</h4><p>public StringBuilder append(任意类型) ；   添加数据，并返回对象本身</p><p>public StringBuilder reverse()；     返回相反的字符序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加和反转方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//public StringBuilder append(任意类型);添加数据，并返回对象本身</span></span><br><span class="line"><span class="comment">//public StringBuilder reverse();返回相反的字符序列</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">StringBuilder sb2=sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2);</span><br><span class="line">System.out.println(<span class="string">&quot;sb2.length():&quot;</span>+sb2.length());</span><br><span class="line">sb.append(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="comment">//链式编程</span></span><br><span class="line">sb.append(<span class="string">&quot; good &quot;</span>).append(<span class="string">&quot;C++ &quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb:&quot;</span>+sb);</span><br><span class="line">System.out.println(<span class="string">&quot;sb.length():&quot;</span>+sb.length());</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(<span class="string">&quot;sb:&quot;</span>+sb);</span><br><span class="line">System.out.println(<span class="string">&quot;sb.length():&quot;</span>+sb.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="StringBuilder和String的相互转换"><a href="#StringBuilder和String的相互转换" class="headerlink" title="StringBuilder和String的相互转换"></a>StringBuilder和String的相互转换</h4><ul><li><p>StringBuilder转换为String</p><p>public String toString()；  通过toSTring可以实现把StringBuilder转换为String</p></li><li><p>String转换为StringBuilder</p><p>public StringBuilder(String str)；  通过构造方法实现把String转换为StringBuilder</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StringTest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">zhuanhuan</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//public String toString();通过toSTring可以实现把StringBuilder转换为String</span></span><br><span class="line"><span class="comment">//public StringBuilder(String str);通过构造方法实现把String转换为StringBuilder</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String str=sb.toString();</span><br><span class="line">System.out.println(str);</span><br><span class="line">String temp=<span class="string">&quot;java&quot;</span>;</span><br><span class="line">StringBuilder temp2=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(temp);</span><br><span class="line">System.out.println(temp2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、正则表达式"><a href="#6、正则表达式" class="headerlink" title="6、正则表达式"></a>6、正则表达式</h3><p>正则表达式可以检验字符串是否满足一定的规则，并用来校验数据格式的合法性。</p><p>作用：</p><ul><li>校验字符串是否满足规则</li><li>在一段文本中查找满足要求的内容</li></ul><p><strong>字符类(只匹配一个字符)</strong></p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>[abc]</td><td>只能是a,b,c</td></tr><tr><td>[^abc]</td><td>除了a,b,c之外的任何字符</td></tr><tr><td>[a-zA-Z]</td><td>a到z，A到Z，包括(范围)</td></tr><tr><td>[a-d[m-p]]</td><td>a到d或者m到p</td></tr><tr><td>[a-z&amp;&amp;[def]]</td><td>a-z和def的交集，为：d,e,f</td></tr><tr><td>[a-z&amp;&amp;[^bc]]</td><td>a-z和非bc的交集。等同于[ad-z]</td></tr><tr><td>[a-z&amp;&amp;[^m-p]]</td><td>a到z除了m到p的交集。等同于[a-lq-z]]</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Regex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//public static matches(String regex): 判断是否与正则表达式匹配，匹配返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只能是a,b,c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------1--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">//false 一个中括号只表示一个字符，含有2个字符故会返回false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能出现a,b,c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------2---------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;zz&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>)); <span class="comment">//false 一个中括号只表示一个字符，含有2个字符故会返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;zz&quot;</span>.matches(<span class="string">&quot;[^abc][^abc]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a到z A到Z（包括头尾的范围）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------3--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aa&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;zz&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a[d[m-p]] a到d 或m-p</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------4--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[a-d[m-p]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d&quot;</span>.matches(<span class="string">&quot;[a-d[m-p]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m&quot;</span>.matches(<span class="string">&quot;[a-d[m-p]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;p&quot;</span>.matches(<span class="string">&quot;[a-d[m-p]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;e&quot;</span>.matches(<span class="string">&quot;[a-d[m-p]]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>.matches(<span class="string">&quot;[a-d[m-p]]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[a-z&amp;&amp;[def]]  a-z和def的交集，为def</span></span><br><span class="line">        <span class="comment">//细节：如果要求两个范围的交集，那么需要写符号&amp;&amp;</span></span><br><span class="line">        <span class="comment">//如果写成了&amp;，那么此时&amp;不表示交集，仅仅表示一个简简单单的符号&amp;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------5---------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[a-z&amp;[def]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&amp;&quot;</span>.matches(<span class="string">&quot;[a-z&amp;[def]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[def]]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[def]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// [a-z&amp;&amp;[^bc]] a-z和非bc的交集。 等同于[ad-z]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------6--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [a-z&amp;&amp;[^m-p]] a到和和除了m到p的交集。 等同于[a-lq-z]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------7--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^m-p]]&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^m-p]]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^m-p]]&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>预定义字符(只匹配一个字符)</strong></p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>任何字符</td></tr><tr><td>\d</td><td>一个数字：[0-9]</td></tr><tr><td>\D</td><td>非数字：[^0-9]</td></tr><tr><td>\s</td><td>一个空白字符[\t\n\x0B\f\r]</td></tr><tr><td>\S</td><td>非空白字符[^\s]</td></tr><tr><td>\w</td><td>[a-zA-Z_0-9] 英文、数字、下划线</td></tr><tr><td>\W</td><td>[^\w]  一个非单词字符</td></tr></tbody></table><p><strong>数量词</strong></p><p>X?     X，一次或0次</p><p>X* X，零次或多次</p><p>X+ X，一次或多次</p><p>X{n}X，至少n次</p><p>X{n,m}至少n但不超过m次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Regex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  \  转义字符  改变后面那个字符原来的含义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// .表示任意一个字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;..&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你a&quot;</span>.matches(<span class="string">&quot;..&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// \\d只能是任意一个数字 简单来记：两个\\表示一个\</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;22&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// \\w表示只能是一位单词字符 [a-zA-Z_0-9]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;_&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;W&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1w&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// \\W 非单词字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\W&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//以上正则表达式只能校验单个字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须是数字 字母 下划线 至少6位</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;22138ws32&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;23_f&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须是数字和字符 必须是4位</span></span><br><span class="line">        System.out.println(<span class="string">&quot;23dF&quot;</span>.matches(<span class="string">&quot;[a-zA-Z_0-9]&#123;4&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;23_F&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;23df&quot;</span>.matches(<span class="string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;23_F&quot;</span>.matches(<span class="string">&quot;\\w&amp;&amp;[^-]&#123;4&#125;&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、ArrayList"><a href="#三、ArrayList" class="headerlink" title="三、ArrayList"></a>三、ArrayList</h2><h3 id="1-ArrayList的构造与添加方法"><a href="#1-ArrayList的构造与添加方法" class="headerlink" title="1.ArrayList的构造与添加方法"></a>1.ArrayList的构造与添加方法</h3><p> ArrayList构造方法：<br>         public ArrayList();创建一个空的对象集合</p><p>  ArrayList添加方法：<br>         public boolean add(E e);&#x2F;&#x2F;将指定元素追加到此集合的末尾<br>         public void add(int index, E element);&#x2F;&#x2F;在此集合的指定位置插入指定的元素   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ArrayList构造方法：</span></span><br><span class="line"><span class="comment">         public ArrayList();创建一个空的对象集合</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">  ArrayList添加方法：</span></span><br><span class="line"><span class="comment">         public boolean add(E e);//将指定元素追加到此集合的末尾</span></span><br><span class="line"><span class="comment">         public void add(int index, E element);//在此集合的指定位置插入指定的元素   </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">case1</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//创建一个空的对象</span></span><br><span class="line">       ArrayList&lt;String&gt; array=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">       <span class="comment">//在集合末尾追加元素</span></span><br><span class="line">       System.out.println(array.add(<span class="string">&quot;Hello&quot;</span>));<span class="comment">//返回的是boolean类型</span></span><br><span class="line">       array.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">       array.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">       <span class="comment">//在集合指定位置添加元素</span></span><br><span class="line">       array.add(<span class="number">1</span>,<span class="string">&quot;good&quot;</span>);</span><br><span class="line">       array.add(<span class="number">4</span>,<span class="string">&quot;people&quot;</span>);</span><br><span class="line">       <span class="comment">//输出集合</span></span><br><span class="line">       System.out.println(<span class="string">&quot;array : &quot;</span>+array);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、ArrayList的常用方法"><a href="#2、ArrayList的常用方法" class="headerlink" title="2、ArrayList的常用方法"></a>2、ArrayList的常用方法</h3><p>public boolean remove(Object o);删除指定元素，返回删除是否成功</p><p> public E remove(int index);删除指定索引位置上的元素，并返回删除元素</p><p> public E set(int index, E element);修改指定位置处的元素，返回被修改的元素</p><p> public E get(int index);返回指定索引处的元素</p><p> public int size();返回集合中元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ArrayList;</span><br><span class="line"><span class="comment">//ArrayList的常用方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public boolean remove(Object o);删除指定元素，返回删除是否成功</span></span><br><span class="line"><span class="comment"> public E remove(int index);删除指定索引位置上的元素，并返回删除元素</span></span><br><span class="line"><span class="comment"> public E set(int index, E element);修改指定位置处的元素，返回被修改的元素</span></span><br><span class="line"><span class="comment"> public E get(int index);返回指定索引处的元素</span></span><br><span class="line"><span class="comment"> public int size();返回集合中元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">case2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">ArrayList&lt;String&gt; array=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">array.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">array.remove(<span class="number">0</span>);</span><br><span class="line">array.remove(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line">array.set(<span class="number">1</span>,<span class="string">&quot;begin&quot;</span>);</span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;下标为2的元素为：&quot;</span>+array.get(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//获取集合元素个数</span></span><br><span class="line">System.out.println(<span class="string">&quot;集合中元素个数为：&quot;</span>+array.size());</span><br><span class="line">System.out.println(<span class="string">&quot;array:&quot;</span>+array);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、面向对象编程"><a href="#四、面向对象编程" class="headerlink" title="四、面向对象编程"></a>四、面向对象编程</h2><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p><p>1.依赖关系</p><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</p><p>2.关联关系</p><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p><p>3.聚合关系</p><p>聚合（Aggregation）关系是 关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。</p><p>4.组合关系</p><p>组合（Composition）关系也是 关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。</p><p>5.泛化（继承）关系</p><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。</p><p>6.实现关系</p><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</p><p>异同分析</p><ul><li><p>聚合和组合的区别：<br>聚合是个体离开了整体，依然可以存在.<br>组合是个体和整体不可以分开，个体不能离开整体单独存在.</p></li><li><p>依赖，关联 和聚合，组合的区别：<br>依赖，关联 : 类之间的关系是在同一层次上.<br>聚合，组合: 类之间的关系表现为整体和部分</p></li></ul><p>在代码层面的体现方式</p><ul><li><p>依赖：<br>一般情况下，依赖关系体现为：局域变量、方法的形参(返回值)、对静态方法的调用。</p></li><li><p>关联：</p><p>一般情况下，关联（组合，聚合都是关联关系的一种）关系体现为：成员变量</p></li></ul><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>在Java语言中，一个类继承另一个类需要使用关键字extends，关键字extends的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">child</span> <span class="keyword">extends</span> <span class="title class_">parent</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>Java只支持单继承，即一个类只有一个父类，子类在继承父类的方法后，创建子类对象的同时也会调用父类的构造方法，其中会先执行父类的构造方法，再执行子类的构造方法。子类继承父类后，可以调用父类创建好的方法和属性。</p><p>继承的好处与弊端：</p><p>好处：</p><ul><li>提高了代码的复用性</li><li>提高了代码的维护性</li></ul><p>弊端：</p><ul><li>继承让类与类之间产生了关系，类的耦合性增强了。当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性</li></ul><hr><p>继承中变量的访问特点</p><p>在子类方法中访问一个变量</p><ol><li>子类局部范围内找</li><li>子类成员范围找</li><li>父类成员范围找</li><li>如果没有就会报错（不考虑父亲的父亲)</li></ol><hr><p><mark>super</mark>关键字</p><p>super关键字和this关键字的用法相似</p><ul><li>this代表本类对象的引用</li><li>super代表父类存储空间的标识（可以理解为父类对象引用）</li></ul><table><thead><tr><th>关键字</th><th>访问成员变量</th><th>访问构造方法</th><th>访问成员方法</th></tr></thead><tbody><tr><td>this</td><td>this.成员变量 访问本类成员变量</td><td>this(……) 访问本类构造方法</td><td>this.成员方法（……）访问本类成员方法</td></tr><tr><td>super</td><td>super.成员变量 访问父类成员变量</td><td>super(……) 访问父类构造方法</td><td>super.成员方法（……）访问父类成员方法</td></tr></tbody></table><hr><p><mark>instanceof</mark>关键字</p><p>该关键字可以用来判断是否一个类实现了某个接口或者用来判断一个实例化对象是否属于一个类，其返回类型是布尔类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quadrangle</span>&#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Quadrangle</span>&#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circular</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Quadrangle q=<span class="keyword">new</span> <span class="title class_">Quadrangle</span>();</span><br><span class="line">        Square s=<span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        System.out.println(q <span class="keyword">instanceof</span> Square);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承中构造方法的访问特点</p><p>子类中所有的构造方法默认都会访问父类中无参的构造方法</p><ul><li>子类会继承父类中的数据，可能还会使用父类中的数据。所以，子类初始化前，一定要先完成父类数据的初始化</li><li>每一个子类构造方法的第一条语句默认为: super()</li></ul><p>如果父类中没有无参构造方法，只有带参构造方法，有两种解决方案：</p><ul><li>通过使用super关键字去显式的调用父类的带参构造方法</li><li>在父类中提供一个无参构造方法</li></ul><hr><p>继承中成员方法的访问特点</p><p>通过子类对象访问一个方法</p><ol><li>子类成员范围中找</li><li>父类范围成员找</li><li>如果都没有则会报错（不考虑父亲的父亲）</li></ol><hr><p>方法重写：</p><ul><li>子类中出现了和父类一样的方法声明</li></ul><p>应用：</p><ul><li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，既沿袭了父类的功能，又定义了子类特有的内容</li></ul><p><mark>@Override</mark></p><ul><li>是一个注解</li><li>可以帮助我们检查重写方法的方法声明的正确性</li></ul><p>注意事项：</p><ul><li>私有方法不能被重写（父类私有成员子类不能继承）</li><li>子类方法的访问权限不能更低（public&gt;默认&gt;私有）</li></ul><hr><p>Java继承中注意事项：</p><ul><li>Java中类只支持单继承，不支持多继承</li><li>Java中类支持多层继承</li></ul><hr><p>修饰符</p><p>1.包的概述与使用</p><p>其实就是文件夹，作用是对类进行分类管理</p><p>包的定义格式：</p><p>package 包名；（多级包.分开)</p><p>带包的Java类编译和执行</p><ul><li><p>手动建包：按照以前的格式编译java文件 javac   xxx.java</p><p>​                   手动创建包                                       在x盘建立文件夹com然后在com下建立文件夹itheima</p><p>​                   把class文件放到包的最里面             把xxx.class文件放到com.itheima这个文件夹下</p><p>​                   带包执行                                          java  com.itheima.xxx</p></li><li><p>自动建包：javac-d .xxx.java                                            java com.itheima.xxx</p></li></ul><p>2.导包</p><p>使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了，为了简化带包的操作，Java提供了导包的功能</p><p>导包的格式：</p><p>import 包名；</p><p>3.修饰符</p><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中子类无关类</th><th>不同包的子类</th><th>不同包的无关类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>状态修饰符：</p><p><mark>final</mark> 最终 可以修饰成员方法，成员变量，类</p><p>final修饰的特点</p><ul><li>修饰方法：表明该方法是最终方法，不能被重写</li><li>修饰变量：表明该变量是常量，不能再次被赋值</li><li>修饰类：表明该类是最终类，不能被继承</li></ul><p>final修饰局部变量</p><ul><li>变量是基本数据类型：final修饰指的是基本数据类型的数据值不能发生改变</li><li>变量是引用类型：final修饰指的是引用类型的地址值不能改变，但是地址里面的内容是可以改变的</li></ul><p><mark>static</mark> 静态 可以修饰成员方法和成员变量</p><p>static修饰的特点</p><ul><li>被类的所有对象共享（这也是判断我们是否使用静态关键字的条件）</li><li>可以通过类名调用（也可以通过对象调用）</li></ul><p>static访问特点</p><p>非静态的成员方法</p><ul><li>能访问静态的成员变量</li><li>能访问非静态的成员变量</li><li>能访问静态的成员方法</li><li>能访问非静态的成员方法</li></ul><p>静态的成员方法</p><ul><li>能访问静态的成员方法</li><li>能访问静态的成员变量</li></ul><hr><h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h3><p>同一个对象，在不同时刻表现出来的不同的形态</p><p>举例：</p><p>猫 cat&#x3D; new 猫（）；</p><p>动物 animal &#x3D;new 猫（）;</p><p>这里猫在不同时刻表现出来了不同的形态，这就是多态。</p><p>多态的前提和体现</p><ul><li>有继承&#x2F;实现关系</li><li>有方法重写</li><li>有父类引用指向子类对象</li></ul><hr><p>多态中成员的访问特点</p><p>成员变量：编译看左边，执行看左边</p><p>成员方法：编译看左边，执行看右边（因为成员方法有重写，而成员变量没有重写）</p><hr><p>多态的好处与弊端</p><p>好处：提高了程序的扩展性</p><p>具体实现：定义方法的时候，使用父类型作为参数，将来使用的时候，使用具体的子类型参与操作</p><p>弊端：不能使用子类的特有功能</p><p><mark><strong>执行顺序</strong>：先执行父类的静态语句（哪句语句在前先执行）再执行子类的静态语句（哪句语句在前先执行），再执行父类的代码块、成员属性赋值（哪个在前哪个先执行），后执行父类的构造方法，最后执行子类的代码块、成员属性赋值（哪个在前哪个先执行），后执行子类的构造方法。</mark></p><hr><p>多态中的转型</p><ul><li><p>向上转型</p><p>从子到父</p><p>父类引用指向子类对象</p></li><li><p>向下转型</p><p>从父到子</p><p>父类引用转化为子类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eat（）方法已重写</span></span><br><span class="line"><span class="comment">//playGame()方法未被重写</span></span><br><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//向上转型</span></span><br><span class="line">        a.eat();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">        Cat c=(Cat)a;</span><br><span class="line">        c.eat();</span><br><span class="line">        c.playGame();</span><br></pre></td></tr></table></figure><hr><p>抽象类</p><p>在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类</p><p>抽象类的特点：</p><ul><li><p>抽象类和抽象方法必须使用<mark>abstract</mark>关键字修饰</p><p>​     public abstract class 类名 {}</p><p>​     public abstract void eat();</p></li><li><p>抽象类中不一定有抽象方法，但有抽象方法的一定是抽象类</p></li><li><p>抽象类不能实例化对象</p></li><li><p>抽象类可以参考多态的形式，通过子类对象实例化，这叫抽象类多态</p></li><li><p>抽象类的子类</p><p>​要么重写抽象类中的所有抽象方法</p><p>​    要么该子类也必须是一个抽象类</p></li></ul><p>抽象类的成员特点：</p><ul><li><p>成员变量</p><p>​可以是变量，也可以是常量</p></li><li><p>构造方法</p><p>​有构造方法，但是不能实例化，构造方法用于子类访问父类数据的初始化</p></li><li><p>成员方法</p><p>​可以有抽象方法：限定子类必须完成某些任务</p><p>​也可以有非抽象类方法：提高代码复用性</p></li></ul><hr><p>接口：</p><p>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用</p><p>Java中的接口更多的体现在对行为的抽象</p><p>接口的特点：</p><ul><li><p>接口用关键字<mark>interface</mark>修饰</p><p>​public interface 接口名 {}</p></li><li><p>类实现接口用<mark>implements</mark>表示</p><p>​public class 类名 implements 接口名{}</p></li><li><p>接口不能实例化</p><p>​接口实例参照多态的方式，通过实现类对象实例化，这叫接口多态</p><p>​多态的形式：具体类多态，抽象类多态，接口多态</p><p>​多态的前提：有继承或者实现关系；有方法重写；有父（类&#x2F;接口）引用指向（子&#x2F;实现）类对象</p></li><li><p>接口的实现类</p><p>​要么重写接口中的所有抽象类方法，要么是抽象类</p></li></ul><p>接口的成员特点：</p><ul><li><p>成员变量</p><p>​只能是常量，默认修饰符：<mark>public static final</mark></p></li><li><p>构造方法：</p><p>​接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在</p><p>​一个类如果没有父类，默认继承超类Object类</p></li><li><p>成员方法：</p><p>​只能是抽象方法，默认修饰符：public abstract</p></li></ul><hr><p>类和接口之间的关系：</p><ul><li><p>类和类的关系</p><p>​继承关系，只能单继承，但是可以多层继承</p></li><li><p>类和接口之间的关系</p><p>​实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p></li><li><p>接口和接口之间的关系</p><p>​继承关系，可以单继承，也可以多继承</p></li></ul><p>抽象类和接口的区别：</p><ul><li><p>成员区别</p><p>​抽象类 变量，常量；有构造方法；有抽象方法，也有非抽象方法</p><p>​接口常量；抽象方法</p></li><li><p>关系区别</p><p>​类与类继承，单继承</p><p>​类与接口实现，可以单实现，也可以多实现</p><p>​接口与接口继承，单继承，多继承</p></li><li><p>设计理念区别</p><p>​抽象类对类抽象，包括属性，行为</p><p>​接口对行为抽象，主要是行为</p></li></ul><p>抽象类是对事物的抽象，而接口是对行为的抽象</p></li></ul><h3 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3.内部类"></a>3.内部类</h3><p>1.类名作为形参和返回值</p><ul><li>方法的形参是类名，其实需要的是该类的对象</li><li>方法的返回值值是类名，其实返回的是该类的对象</li></ul><p>2.抽象类名作为形参和返回值</p><ul><li>方法的形参是抽象类名，其实需要的是该抽象类的子类对象</li><li>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</li></ul><p>3.接口名作为形参和返回值</p><ul><li>方法的形参是接口名，其实需要的是该接口的实现类对象</li><li>方法的返回值是接口名，其实返回的是该接口的实现类对象</li></ul><hr><p>内部类：就是在一个类中定义一个类。</p><p>内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">    修饰符 class 类名&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类的访问特点：</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><p>成员内部类不止可以在外部类中使用，在其他类中也可以使用。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类 outer =<span class="keyword">new</span> 外部类();</span><br><span class="line">外部类.内部类 inter=<span class="keyword">new</span> <span class="title class_">outer</span>.new 内部类();</span><br></pre></td></tr></table></figure><ul><li>如果在外部类和非静态方法之外实例化内部类对象，需要使用“外部类.内部类”的形式指向该对象的类型。</li><li>内部类对象会依赖于外部类对象，除非已经存在一个外部类对象，否则类中不会出现内部类对象。</li></ul><p>使用<mark>this</mark>关键字获取内部类和外部类之间的引用</p><p>​如果在外部类中定义的成员变量与内部类的成员变量名称相同，可以使用this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheSameName</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x=<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inter</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">11</span>;</span><br><span class="line">            x++;<span class="comment">//局部变量x++</span></span><br><span class="line">            <span class="built_in">this</span>.x++;<span class="comment">//内部类中的成员变量x++</span></span><br><span class="line">            TheSameName.<span class="built_in">this</span>.x++;<span class="comment">//外部类中的成员变量x++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类：</p><p>匿名内部类是在创建对象时才会编写类体的一种写法，匿名类的特点是“<mark>现用现写</mark>”，其语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口&#123;</span><br><span class="line">    子类实现的内容</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：最后一个大括号之后有<strong>分号</strong></p><p>匿名类的特点：</p><ul><li>匿名类不能写构造方法</li><li>匿名类不能定义静态的成员变量</li><li>如果匿名类创建的对象没有赋值给任何引用变量，会导致该对象用完一次后就会被Java虚拟机销毁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用匿名类创建一个抽象狗类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    String Color;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Dog temp=<span class="keyword">new</span> <span class="title class_">Dog</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;四腿狂奔&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;嗷呜~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        temp.Color=<span class="string">&quot;灰色&quot;</span>;</span><br><span class="line">        temp.move();</span><br><span class="line">        temp.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：匿名内部类编译以后，会产生以“外部类名$序号”为名称的.class文件，序号以1~n排列，分别代表1-n个匿名内部类。</p><h3 id="4-Object类"><a href="#4-Object类" class="headerlink" title="4.Object类"></a>4.Object类</h3><p>Java中所有类都直接或者间接继承了java.lang.Object类.Object类是比较特殊的类，它是所有类的父类，是Java类中的最高层类。</p><p>Object类的常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getClass()</td><td>它会返回对象执行时的Class实例，此外也可以通过此实例调用getName()方法取得类名。getClass().getName();</td></tr><tr><td>toString()</td><td>将一个对象返回以字符串的形式，它会返回一个String实例。</td></tr><tr><td>equals()</td><td>“&#x3D;&#x3D;”比较的是两个对象引用地址是否相等，而equals()比较的是两个对象的实际内容。</td></tr></tbody></table><p>toString()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//toString 返回对象的字符串表示形式</span></span><br><span class="line">        <span class="comment">//包名 + 类名 + 地址值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> obj.toString();</span><br><span class="line">        System.out.println(str1);   <span class="comment">//java.lang.Object@723279cf</span></span><br><span class="line">        System.out.println(obj);    <span class="comment">//直接打印也可以获得相同结果</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * System：类名</span></span><br><span class="line"><span class="comment">        * out：静态变量</span></span><br><span class="line"><span class="comment">        * System.out：获取打印的对象</span></span><br><span class="line"><span class="comment">        * print()：方法，会调用toString</span></span><br><span class="line"><span class="comment">        * 参数：表示打印的内容</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">//如果要打印对象属性，可以重写toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>equals()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//IDEA中使用 alt + insert，快捷重写equals方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//同一个对象，直接true</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;  <span class="comment">//强转成子类对象</span></span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);    <span class="comment">//进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、常用API"><a href="#五、常用API" class="headerlink" title="五、常用API"></a>五、常用API</h2><h3 id="1-Math类"><a href="#1-Math类" class="headerlink" title="1.Math类"></a>1.Math类</h3><p>Math包括执行基本数学运算的方法，如基本指数，对数，平方根和三角函数。</p><p>调用形式：</p><p>Math.数学方法 </p><p>也存在一些常用数字常量 如：Math.PI        Math.E</p><p>1.三角函数方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//返回角的正弦值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">cos</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">// 返回角的余弦值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">tan</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//返回角的正切值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">asin</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">// 返回一个值的反正弦</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">acos</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//返回一个值的反余弦</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">atan</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//返回一个值的反正切</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">toRadians</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//将角度转化为弧度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">toDegrees</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//将弧度转化为角度</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>2.指数函数方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">exp</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//获取e的a次方，即取e^a的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//用于取自然对数，即lna的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//用于取底数为10的a的对数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//用于取a的算术平方根，其中a的值不能为负值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">cbrt</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//用于取a的立方根</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>;<span class="comment">//用于取a的b次方</span></span><br></pre></td></tr></table></figure><p>3.取整函数方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//返回大于等于参数的最小整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//返回小于等于参数的最小整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">rint</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//返回与参数最接近的整数，若存在两个同样接近的数，取偶数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//四舍五入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//四舍五入，然后强制转换为长整型</span></span><br></pre></td></tr></table></figure><p>4.取最大值、最小值、绝对值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>;<span class="comment">//取最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>/<span class="type">long</span>/<span class="type">float</span>/<span class="type">double</span> <span class="title function_">min</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>;<span class="comment">//取最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>/<span class="type">long</span>/<span class="type">float</span>/<span class="type">double</span> <span class="title function_">abs</span><span class="params">(<span class="type">double</span> a)</span>;<span class="comment">//返回int/long/float/double类型参数的绝对值</span></span><br></pre></td></tr></table></figure><h3 id="2-BigInteger类"><a href="#2-BigInteger类" class="headerlink" title="2.BigInteger类"></a>2.BigInteger类</h3><p>BigInteger类的数字范围比Integer类的大得多，BigInteger类支持任意精度的整数，使用BigInteger类进行运算可以准确无误地表示任何大小的整数值并且不会丢失任何信息。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">twoInstance</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">//参数2的双引号不能省略，因为参数是以字符串的形式存在的</span></span><br></pre></td></tr></table></figure><p>BigInteger类的常用运算方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">add</span><span class="params">(BigInteger val)</span>;<span class="comment">//做加法运算</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger val)</span>;<span class="comment">//做减法运算</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger val)</span>;<span class="comment">//做乘法运算</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">divide</span><span class="params">(BigInteger val)</span>;<span class="comment">//做除法运算</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">remainder</span><span class="params">(BigInteger val)</span>;<span class="comment">//做取余运算</span></span><br><span class="line"><span class="keyword">public</span> BigInteger[] divideAndRemainder(BigInteger val);<span class="comment">//用数组返回余数和商，数组的第一个值为商，第二个值为余数</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">pow</span><span class="params">(<span class="type">int</span> exponent)</span>;<span class="comment">//进行取参数的exponent次方操作</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">negate</span><span class="params">()</span>;<span class="comment">//取相反数</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">shiftLeft</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//数字左移n位，若n为负数，则右移</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">shiftRight</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//数字右移n位，若n为负数，则左移</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">and</span><span class="params">(BigInteger val)</span>;<span class="comment">//与操作</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">or</span><span class="params">(BigInteger val)</span>;<span class="comment">//或操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(BigInteger val)</span>;<span class="comment">//做数字比较操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object x)</span>;<span class="comment">//当参数x是BigInteger类并且数值与对象实例的数值相等时，返回true</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">max</span><span class="params">(BigIntegr val)</span>;<span class="comment">//返回较大的数值</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">min</span><span class="params">(BigInteger val)</span>;<span class="comment">//返回较小的数值</span></span><br></pre></td></tr></table></figure><p>样例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        BigInteger x=<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;222222222&quot;</span>);</span><br><span class="line">        BigInteger y=<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;111111111&quot;</span>);</span><br><span class="line">        BigInteger z=x.add(y);<span class="comment">//加法</span></span><br><span class="line">        BigInteger c=x.subtract(y);<span class="comment">//减法</span></span><br><span class="line">        BigInteger v=x.multiply(y);<span class="comment">//乘法</span></span><br><span class="line">        BigInteger u=x.divide(y);<span class="comment">//除法</span></span><br><span class="line">        BigInteger r=x.remainder(y);<span class="comment">//取余</span></span><br><span class="line">        BigInteger Max=x.max(y);<span class="comment">//取最大值</span></span><br><span class="line">        BigInteger Min=x.min(y);<span class="comment">//取最小值</span></span><br><span class="line">        BigInteger yu=x.and(y);<span class="comment">//与运算</span></span><br><span class="line">        BigInteger huo=x.or(y);<span class="comment">//或运算</span></span><br><span class="line">        BigInteger oppo=x.negate();<span class="comment">//取相反数</span></span><br><span class="line">        BigInteger exp=x.pow(<span class="number">2</span>);<span class="comment">//进行取参数的exponent次方操作</span></span><br><span class="line">        <span class="type">int</span> ans=x.compareTo(y);<span class="comment">//做数字的比较操作,大于参数返回正整数，等于返回0，小于返回负整数</span></span><br><span class="line">        BigInteger left=x.shiftLeft(<span class="number">1</span>);<span class="comment">//将数字左移n位，如果n为负数，做右移操作</span></span><br><span class="line">        BigInteger right=x.shiftRight(<span class="number">1</span>);<span class="comment">//将数字右移n位，如果n为负数，做左移操作</span></span><br><span class="line">        BigInteger []arr=x.divideAndRemainder(y);<span class="comment">//用数组返回余数和商，结果数组中第一个值为商，第二个值为余数</span></span><br><span class="line">        <span class="type">boolean</span> flag=x.equals(<span class="number">12</span>);<span class="comment">//当参数x是BigInteger类型的数字并且数值与对象实例的数值相等时，返回true，否则返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;加法运算后的结果：&quot;</span>+z);</span><br><span class="line">        System.out.println(<span class="string">&quot;减法运算后的结果：&quot;</span>+c);</span><br><span class="line">        System.out.println(<span class="string">&quot;乘法运算后的结果：&quot;</span>+v);</span><br><span class="line">        System.out.println(<span class="string">&quot;除法运算后的结果：&quot;</span>+u);</span><br><span class="line">        System.out.println(<span class="string">&quot;取余运算后的结果：&quot;</span>+r);</span><br><span class="line">        System.out.println(<span class="string">&quot;两者中的最大值为：&quot;</span>+Max);</span><br><span class="line">        System.out.println(<span class="string">&quot;两者中的最小值为：&quot;</span>+Min);</span><br><span class="line">        System.out.println(<span class="string">&quot;与操作后的结果：&quot;</span>+yu);</span><br><span class="line">        System.out.println(<span class="string">&quot;或操作后的结果：&quot;</span>+huo);</span><br><span class="line">        System.out.println(<span class="string">&quot;相反数为：&quot;</span>+oppo);</span><br><span class="line">        System.out.println(<span class="string">&quot;参数的2次方结果为：&quot;</span>+exp);</span><br><span class="line">        System.out.println(<span class="string">&quot;做比较操作后的结果为：&quot;</span>+ans);</span><br><span class="line">        System.out.println(<span class="string">&quot;做左移1位后的结果:&quot;</span>+left);</span><br><span class="line">        System.out.println(<span class="string">&quot;做右移1位后的结果：&quot;</span>+right);</span><br><span class="line">        System.out.println(<span class="string">&quot;商：&quot;</span>+arr[<span class="number">0</span>]+<span class="string">&quot; 余数：&quot;</span>+arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;判断参数与12是否相等：&quot;</span>+flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-System类"><a href="#3-System类" class="headerlink" title="3.System类"></a>3.System类</h3><p>System类是JDK提供的系统类，该类是用<mark>final</mark>修饰的，所以不允许继承，System类提供了很多系统层面的操作方法，并且这些方法全部都是静态的。以下为System类常用方法：</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>currentTimeMillis()</td><td>返回以毫秒为单位的当前时间</td></tr><tr><td>exit(int status)</td><td>通过启动虚拟机的关闭序列，终止当前正在运行的Java虚拟机，此方法从不正常返回，可以将变量作为一个状态码，根据惯例，非零的状态码表示非正常终止；0表示正常终止</td></tr><tr><td>Map<String String>getenv()</td><td>返回一个不能修改的当前系统环境的字符串映射视图</td></tr><tr><td>getenv(String name)</td><td>获取指定的环境变量值</td></tr><tr><td>getProperties()</td><td>确定当前的系统属性</td></tr><tr><td>getProperty(String key)</td><td>获取用指定键描述的系统属性</td></tr><tr><td>setIn(InputStream in)</td><td>重新分配“标准输入流”</td></tr></tbody></table><p>System类提供了标准输入、标准输出和错误输出流，即System类提供了三个静态对象：in、out、err.在控制台输出字符串，有两种方法：</p><ul><li>不会自动换行的print()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>会自动换行的println()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;书籍是人类进步的阶梯&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>System.out.println(“\n”);   &#x2F;&#x2F;会打印两个空行</li><li>System.out.print();          &#x2F;&#x2F;没有参数会报错</li></ul><p>计时</p><p>利用System.currentTimeMillis()方法可以用来记录程序的运行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">long</span> start=System.currentTimeMillis();<span class="comment">//程序开始记录时间</span></span><br><span class="line">        String str=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            str+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> end=System.currentTimeMillis();<span class="comment">//记录循环结束时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;循环用时为：&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Arrays类"><a href="#4-Arrays类" class="headerlink" title="4.Arrays类"></a>4.Arrays类</h3><p>Array类包含于用于操作数组的各种方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回指定数组的内容的字符串表达形式</td></tr><tr><td>public static void sort(int[] a)</td><td>按照数字顺序排列指定的数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">20</span>,<span class="number">69</span>,<span class="number">80</span>,<span class="number">57</span>,<span class="number">13</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工具类的设计思想：</p><ul><li>构造方法用private修饰</li><li>成员用public static修饰</li></ul><h3 id="5-基本类型包装类"><a href="#5-基本类型包装类" class="headerlink" title="5.基本类型包装类"></a>5.基本类型包装类</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p><p>常用的操作之一：用于基本数据类型和字符串之间的转换</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>Integer类的概述和使用</p><p>Integer:包装一个对象中的原始类型int的值</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int value)</td><td>根据int值创建Integer对象（过时）</td></tr><tr><td>public Integer(String s)</td><td>根据String值创建Integer对象（过时）</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回指定的int值的Integer实例</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回一个保存指定值的Interger对象String</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Integer i1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);<span class="comment">//过时</span></span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        Integer i2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;100&quot;</span>);<span class="comment">//过时 字符串里面的内容必须由数字组成</span></span><br><span class="line">        System.out.println(i2);</span><br><span class="line">        Integer i3=Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i3);</span><br><span class="line">        Integer i4=Integer.valueOf(<span class="string">&quot;100&quot;</span>);<span class="comment">//字符串里面的内容必须由数字组成</span></span><br><span class="line">        System.out.println(i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>int和String的相互转换</p><p>1.int →String类型</p><ul><li>public static String valueOf(int i):返回int类型参数的字符串表示形式，该方法是String类中的方法。</li></ul><p>2.String →int类型</p><ul><li>public  static int parseInt(String s);将字符串解析成int类型，该方法是Integer类中的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -- String 的相互转换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> number=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">///int -&gt;String</span></span><br><span class="line">        <span class="comment">//方式1 +</span></span><br><span class="line">        String s=<span class="string">&quot;&quot;</span>+number;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//方式2 public static String valueOf(int i)</span></span><br><span class="line">        String s2=String.valueOf(number);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//String -&gt; int</span></span><br><span class="line">        String str=<span class="string">&quot;1000&quot;</span>;</span><br><span class="line">        <span class="comment">//方式1 String -&gt; Integer -&gt; int</span></span><br><span class="line">        Integer temp=Integer.valueOf(str);</span><br><span class="line">        <span class="type">int</span> x=temp.intValue();</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        <span class="comment">//方式2 public static int parseInt(String s)</span></span><br><span class="line">        <span class="type">int</span> y=Integer.parseInt(str);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-日期时间类"><a href="#6-日期时间类" class="headerlink" title="6.日期时间类"></a>6.日期时间类</h3><h4 id="1-Date类"><a href="#1-Date类" class="headerlink" title="1.Date类"></a>1.Date类</h4><p>Date类用于表示日期和时间，使用该类表示时间需要使用其构造方法来创建对象，其构造方法以及说明表如下。</p><p>​</p><table><thead><tr><th>构造方法</th><th>方法说明</th></tr></thead><tbody><tr><td>Date()</td><td>分配Date对象并初始化对象，以表示分配它的时间(精确到毫秒)</td></tr><tr><td>Date(long date)</td><td>分配Date对象并初始化此对象，以表示自标准基准时间(即1970年1月1日00：00：00GMT)起经过指定毫秒数date后的时间</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> timeMillis=System.currentTimeMillis();  <span class="comment">//当前系统时间所经历的毫秒数</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Date</span>(timeMillis);</span><br></pre></td></tr></table></figure><p>创建Date对象使用的是long型整数，而不是double型，这主要是因为double类型可能会损失精度。</p><p>​Date类的常用方法以及说明</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>after(Date when)</td><td>测试当前日期是否在指定日期之后</td></tr><tr><td>before(Date when)</td><td>测试当前日期是否在指定日期之前</td></tr><tr><td>getTime()</td><td>获取自1970年1月1日00：00：00GMT开始到现在所经过的毫秒数</td></tr><tr><td>setTime(long time)</td><td>设置当前Date对象所表示的日期时间值，该值用以1970年1月1日00：00：00GMT以后time毫秒的时间点</td></tr></tbody></table><p>案例1：</p><p>​获取当前的日期和时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> APIDemp;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDmo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Date date=<span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//创建现在的日期</span></span><br><span class="line">        <span class="type">long</span> value=date.getTime();<span class="comment">//获取毫秒数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;日期： &quot;</span>+date);</span><br><span class="line">        System.out.println(<span class="string">&quot;到现在所经历的毫秒数：&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日期时间格式化</p><p>​DateFormat类是日期时间格式化子类的抽象类，可以按照指定的格式对日期或时间进行格式化。DateFormat类提供了很多类方法，以获得基于默认或给定语言环境和多种格式化风格的默认日期时间Formatter,格式化主要包括四种风格：</p><p>SHORT：完全为数字，如12.13.52或3：30pm</p><p>MEDIUM：较长，如Jan 12, 1952</p><p>LONG：更长，如January 12，1953或3：39：32pm</p><p>FULL：完全指定，如Tuesday、April 12、1952AD或3：30：34pm PST</p><p>另外，使用DateFormat类还可以自定义日期时间的格式。要格式化一个当前语言环境下的日期，首先要创建一个DateFormat类的一个对象，由于它是抽象类，因此可以使用getDateInstance()进行创建，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> DateFormat.getDateLnstance();</span><br></pre></td></tr></table></figure><p>使用getDateInstance()方法获取的是所在国家或地区的标准日期格式，而使用getTimeInstance()获取的是当前所在国家或地区的时间格式，而使用getDateTimeInstance()获取的是当前国家或者地区的日期时间格式。</p><p>​DateFormat类的常用方法及其说明</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>format(Date date)</td><td>将一个Date对象实例格式化为日期&#x2F;时间字符串</td></tr><tr><td>getCalendar()</td><td>获取与此日期时间&#x2F;时间格式器关联的日历</td></tr><tr><td>getDateInstance()</td><td>获取日期格式器，该格式器具有默认语言环境的默认格式化风格</td></tr><tr><td>getTimeInstance()</td><td>获取时间格式器，该格式器具有默认语言环境的默认格式化风格</td></tr><tr><td>getDateTimeInstance()</td><td>获取日期&#x2F;时间格式器，该格式器具有默认语言环境的默认格式化风格</td></tr><tr><td>getInstance()</td><td>获取为日期&#x2F;时间使用SHORT风格的默认日期&#x2F;时间格式器</td></tr><tr><td>parse(String source)</td><td>将字符串解析成一个日期，并返回这个日期的Date对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> APIDemp;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDmo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="comment">// DateFormat df=DateFormat.getTimeInstance(DateFormat.LONG);</span></span><br><span class="line">       <span class="comment">// DateFormat df=DateFormat.getDateInstance(DateFormat.LONG);</span></span><br><span class="line">        DateFormat df=DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</span><br><span class="line">        DateFormat df2=DateFormat.getInstance();</span><br><span class="line">        Date date=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(df.format(date));</span><br><span class="line">        <span class="comment">//System.out.println(df.getCalendar());</span></span><br><span class="line">        System.out.println(df.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        System.out.println(df2.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​由于DateFormat类是一个抽象类，不能new创建实例对象。因此，出来使用getXXXinstance()方法创建其对象，还可以使用其子类，如SimpleDateFormat类，该类是一个以与语言环境相关的方式来格式化和分析日期的具体类，它允许进行格式化(日期→文本)、分析(文本→日期)和规范化。</p><p>​SimpleDateFormat的格式化字符</p><table><thead><tr><th>字母</th><th>日期或时间元素</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td>G</td><td>Era标示符</td><td>Text</td><td>AD</td></tr><tr><td>y</td><td>年</td><td>Year</td><td>1996</td></tr><tr><td>M</td><td>年中的月份</td><td>Month</td><td>July;Jul;07</td></tr><tr><td>w</td><td>年中的天数</td><td>Number</td><td>27</td></tr><tr><td>W</td><td>月份中的天数</td><td>Number</td><td>2</td></tr><tr><td>D</td><td>年中的天数</td><td>Number</td><td>179</td></tr><tr><td>d</td><td>月份中的天数</td><td>Number</td><td>10</td></tr><tr><td>F</td><td>月份中的星期</td><td>Number</td><td>2</td></tr><tr><td>E</td><td>星期中的天数</td><td>Text</td><td>Tuesday;Tue</td></tr><tr><td>t</td><td>Am&#x2F;pm的标记</td><td>Text</td><td>PM</td></tr><tr><td>H</td><td>一天中的小时数(0~23)</td><td>Number</td><td>0</td></tr><tr><td>h</td><td>am&#x2F;pm中的小时数(1~12)</td><td>Number</td><td>12</td></tr><tr><td>k</td><td>一天中的小时数(1~24)</td><td>Number</td><td>24</td></tr><tr><td>K</td><td>am&#x2F;pm中的小时数(0~11)</td><td>Number</td><td>0</td></tr><tr><td>m</td><td>小时中的分钟数</td><td>Number</td><td>30</td></tr><tr><td>s</td><td>分钟中的秒数</td><td>Number</td><td>55</td></tr><tr><td>S</td><td>毫秒数</td><td>Number</td><td>978</td></tr><tr><td>z</td><td>时区</td><td>General time zone</td><td>PST</td></tr><tr><td>Z</td><td>时区</td><td>RFC 822 time zone</td><td>-800</td></tr></tbody></table><p>​常用时间格式</p><table><thead><tr><th>日期时间</th><th>对于的格式</th></tr></thead><tbody><tr><td>2021&#x2F;10&#x2F;25</td><td>yyyy&#x2F;MM&#x2F;dd</td></tr><tr><td>2021.10.25</td><td>yyyy.MM.dd</td></tr><tr><td>2021-09-14 13：20：43</td><td>yyyy-MM-dd HH:mm:ss</td></tr><tr><td>2021年10月21日 10时21分05秒 星期日</td><td>yyyy年MM月dd日 HH时mm分ss秒 EEEE</td></tr><tr><td>下午3时</td><td>ah时</td></tr><tr><td>今年已经过去了297天</td><td>今年已经过去了D天</td></tr></tbody></table><p>案例2：</p><p>​以中文形式打印当前的日期和时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> APIDemp;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDmo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        DateFormat df=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 EEEE&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;各位观众大家好，现在是：&quot;</span>);</span><br><span class="line">        System.out.print(df.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        System.out.println(<span class="string">&quot;, 欢迎大家收看新闻&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-集合类"><a href="#7-集合类" class="headerlink" title="7.集合类"></a>7.集合类</h3><p>​集合可以看成一个容器，Java中提供了不同的集合类，这些类有不同的存储对象，同时提供了相应的方法，以方便用户对集合进行遍历、添加、删除和查找指定的对象。集合类与数组的不同之处是：数组长度是固定的，集合的长度是可变的；数组常用来存储基本类型的数据，集合用来存放对象的引用。常用的集合有List集合、Set集合和Map集合，其中List集合与Set集合继承了Collection接口，各接口还提供了不同的实现类。</p><h4 id="1-Collection接口"><a href="#1-Collection接口" class="headerlink" title="1.Collection接口"></a>1.Collection接口</h4><p>​Collection接口是层次结构中的根接口，构成Collection的单位称为元素。Collection接口通常不能直接使用，但该接口提供了添加元素、删除元素、管理数据的方法。由于List接口与Set接口都继承了Collection接口，因此这些方法对List集合与Set集合是通用的。Collection接口的常用方法如下：</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>add(E e)</td><td>将指定对象添加到集合中</td></tr><tr><td>remove(Object o)</td><td>将指定的对象从该集合中移除</td></tr><tr><td>isEmpty()</td><td>返回boolean值，用于判断当前集合是否为空</td></tr><tr><td>iterator()</td><td>返回在此Collection的元素上进行迭代的迭代器，用于遍历集合中的对象</td></tr><tr><td>size()</td><td>返回int型值，获取该集合中元素的个数</td></tr></tbody></table><p>​通常遍历集合，都是通过迭代器来实现</p><p>案例：</p><p>​向购物车添加商品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> APIDemp;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Collection&lt;String&gt;list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//实例化集合对象</span></span><br><span class="line">        list.add(<span class="string">&quot;《Java从入门到精通》&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;《零基础学Java》&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;《Java编程思想》&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it=list.iterator();<span class="comment">//创建迭代器</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//判断是否有下一个元素</span></span><br><span class="line">            String str=(String)it.next();<span class="comment">//获取集合中的元素</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2.List集合"></a>2.List集合</h4><p>1.List接口</p><p>​List接口继承了Collection接口，因此包含Collection接口中的所有方法。此外List接口还定义了两个重要的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>get(int index)</td><td>获得指定索引位置的元素</td></tr><tr><td>set(int index,Object obj)</td><td>将集合中指定索引位置的对象修改为指定的对象</td></tr></tbody></table><p>2.List接口的实现类</p><ul><li>ArrayList类实现了可变的数组，允许保存所有元素，包括null，并可以根据索引位置对集合进行快速的随机访问。缺点是向指定的索引位置插入对象或者删除对象的速度较慢。</li><li>LinkedList类采用链表的结构保存对象。这种结构的优点是便于向集合中插入和删除元素。需要向集合中插入、删除对象时，使用LinkedList类实现的List集合的效率较高；但对于随机访问集合中的元素，使用LinkedList类实现List集合的效率较低。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><mark>注意：与数组相同，集合的索引也是从0开始的。</mark></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> APIDemp;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//创建集合对象</span></span><br><span class="line">        <span class="comment">//向集合中添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.set(<span class="number">0</span>,<span class="string">&quot;d&quot;</span>);<span class="comment">//修改0索引位置上的元素值</span></span><br><span class="line">        <span class="type">int</span> i=(<span class="type">int</span>)(Math.random()*list.size());<span class="comment">//获得0~2的随机数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;随机获取集合中的元素：&quot;</span>+list.get(i));</span><br><span class="line">        list.remove(i);<span class="comment">//将指定索引位置中的元素从集合中移除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中剩下的元素分别是：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;list.size();j++)&#123;</span><br><span class="line">            System.out.println(list.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Set集合"><a href="#3-Set集合" class="headerlink" title="3.Set集合"></a>3.Set集合</h4><p>​Set集合中的对象不按特定的方式排序，只是简单地把对象加入到集合中，但Set集合中不能包含重复对象。Set集合由Set接口和Set接口的实现类组成。因此包含Collection接口的所有方法。</p><p>​Set接口常用的实现类有HashSet类和TreeSet类，简述如下：</p><ul><li>HashSet类实现Set接口，由哈希表(实际上是一个HashMap实例)支持。它不保证Set集合的迭代顺序，特别是它不保证该顺序永恒不变。此类允许使用元素null。</li><li>TreeSet类不仅实现了Set接口，还实现了java.util.SortSet接口，因此TreeSet类实现的Set集合在遍历集合按照自然顺序递增排序，也可以按照指定比较器递增排序，即可以通过比较器对用TreeSet类实现的Set集合中的对象进行排序。</li></ul><p>​TreeSet类增加的方法</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>first()</td><td>返回此Set集合中当前第一个(最低)元素</td></tr><tr><td>last()</td><td>返回此Set集合中当前最后一个(最高)元素</td></tr><tr><td>comparator()</td><td>返回对此Set集合中的元素是进行排序的比较器。如果该集合采用的是自然顺序排序，则返回null</td></tr><tr><td>headSet(E toElenment)</td><td>返回一个新的Set集合，新集合是toElement对象(不包含)之前的所有对象</td></tr><tr><td>subSet(E fromElement，E fromElement)</td><td>返回一个新的Set集合，新集合是fromElement对象(包含)与fromElement对象(不包含)之间的所有对象</td></tr><tr><td>tailSet(E fromElement)</td><td>返回一个新的Set集合，新集合包含fromElement对象(包含)之后的所有对象</td></tr></tbody></table><p>案例：</p><p>​使用TreeSet类完成自然(升序)排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> APIDemp;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; temp=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        temp.add(<span class="number">12</span>);</span><br><span class="line">        temp.add(<span class="number">21</span>);</span><br><span class="line">        temp.add(-<span class="number">3</span>);</span><br><span class="line">        temp.add(<span class="number">6</span>);</span><br><span class="line">        temp.add(<span class="number">85</span>);</span><br><span class="line">        <span class="comment">//temp.add(12);  重复元素不会被添加</span></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的第一个元素：&quot;</span>+temp.first());</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的最后一个元素：&quot;</span>+temp.last());</span><br><span class="line">        Iterator&lt;Integer&gt; it=temp.iterator();</span><br><span class="line">        System.out.print(<span class="string">&quot;temp中的集合元素为：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            System.out.print(it.next()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//headSet</span></span><br><span class="line">        Set&lt;Integer&gt; temp2=temp.headSet(<span class="number">12</span>);<span class="comment">//截取当前元素前面的元素，不包含当前元素</span></span><br><span class="line">        Iterator&lt;Integer&gt; it2=temp2.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;temp2中的集合元素为：&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">                System.out.print(it2.next()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//tailSet</span></span><br><span class="line">        Set&lt;Integer&gt; temp3=temp.tailSet(<span class="number">12</span>);<span class="comment">//截取当前元素后面的元素，包含当前元素</span></span><br><span class="line">        Iterator&lt;Integer&gt; it3=temp3.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it3.hasNext())&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;temp3中的集合元素为：&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(it3.hasNext())&#123;</span><br><span class="line">                System.out.print(it3.next()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//subSet</span></span><br><span class="line">        Set&lt;Integer&gt; temp4=temp.subSet(<span class="number">6</span>,<span class="number">21</span>);<span class="comment">//截取两个元素之前的元素，包含前面元素，不包含后面元素</span></span><br><span class="line">        Iterator&lt;Integer&gt; it4=temp4.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it4.hasNext())&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;temp4中的集合元素为：&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(it4.hasNext())&#123;</span><br><span class="line">                System.out.print(it4.next()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Map集合"><a href="#4-Map集合" class="headerlink" title="4.Map集合"></a>4.Map集合</h4><p>​Map集合没有继承Collection接口，其提供的是key到value的映射。Map集合中不能包含相同的Key，每个key只能映射一个value.key还决定了存储对象在映射中的存储位置，但不是由key对象本身决定的，而是通过一种”散列技术”进行处理，产生一个散列码的整数值。散列码通常用作一个偏移量，该偏移量对应分配给映射的内存区域的起始位置，从而确定存储对象在映射中的存储位置。Map集合包含Map接口和Map接口的所有实现类。</p><p>1.Map接口</p><p>​Map接口提供了将key映射到值的对象。一个映射不能包含重复的key，每个key最多只能映射到一个值。除集合的常用方法外，Map接口还提供了下图所示方法：</p><p>​Map常用方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>put(K key，V value)</td><td>向集合中添加所指定的key与value的映射关系</td></tr><tr><td>containsKey(Object key)</td><td>如果此映射中包含指定key的映射关系，则返回true</td></tr><tr><td>contaninsValue(Object value)</td><td>如果此映射将一个或者多个key映射到指定值，则返回true</td></tr><tr><td>get(Object key)</td><td>如果存在指定的key对象，则返回该对象的值，否则返回null</td></tr><tr><td>keySet()</td><td>返回该集合中的所有key对象形成的Set集合</td></tr><tr><td>values()</td><td>返回该集合中的所有值对象形成的Collectin集合</td></tr><tr><td>remove(Object key)</td><td>从映射中删除与Key相关的映射</td></tr><tr><td>putAll(Map t)</td><td>将来自特定映像的所有元素添加给该映像</td></tr><tr><td>clear()</td><td>删除所有映射</td></tr></tbody></table><p>2.Map接口的实现类</p><ul><li><p>SortedMap接口 用来保持键的有序顺序</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>Comparator comparator()</td><td>返回对关键字进行排序时使用的比较器，如果使用Comparable接口的compareTo() 方法进行关键字比较，则返回null</td></tr><tr><td>Object firstKey()</td><td>返回映射中第一个(最低)关键字</td></tr><tr><td>Object lastKey()</td><td>返回映射中最后一个(最高)关键字</td></tr><tr><td>SortedMap subMap(Object fromKey，Object toKey)</td><td>返回从fromKey(包括)到toKey(不包括)范围内的元素的SortedMap视图(子集)</td></tr><tr><td>SortedMap headMap(Object toKey)</td><td>返回SortedMap的第一个视图，其内各元素的key都小于toKey</td></tr><tr><td>SortedMap tailMap(Object fromKey)</td><td>返回SortedMap中的最后一个视图，里面元素的key都大于或者等于fromKey</td></tr></tbody></table></li><li><p>HashMap是基于哈希表的Map接口实现，此实现提供所有可选的映射操作，并允许使用null值和null键，但必须保证键的唯一性。HashMap类通过哈希表对其内部的映射关系进行快速查找。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></li><li><p>TreeMap类不仅实现了Map接口，还实现了java.util.SortMap接口，因此集合中的映射关系具有一定的顺序。但在添加、删除、定位映射关系时，TreeMap类比HashMap类性能较差。由于TreeMap类实现的Map集合中的映射关系是根据键对象按照一定的顺序排列的，因此不允许键对象是null。</p></li></ul><h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><p><strong>泛型</strong>：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型 它的本质是<mark><strong>参数化类型</strong></mark>，也就是说所操作的数据类型被指定为一个参数，顾名思义，就是<strong>将类型由原来的具体的类型参数化，然后在使用&#x2F;调用时传入具体的类型</strong>，这种参数类型可以用在类、方法和接口中，分别称为泛型类、泛型方法、泛型接口</p><p>泛型定义格式：</p><ul><li>&lt;类型&gt; : 指定一种类型的格式，这里的类型可以看成是形参</li><li>&lt;类型1，类型2&gt;：指定多种类型的格式，多种类型用逗号隔开。这里的类型可以看成是形参</li><li>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</li></ul><p>泛型的好处：</p><ul><li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    需求：Collection集合存储字符串并遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line"><span class="comment">//        Collection c = new ArrayList();</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">       <span class="comment">// c.add(100);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="comment">//Iterator it = c.iterator();</span></span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(obj);</span></span><br><span class="line"><span class="comment">//            String s = (String)it.next();  //ClassCastException</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();  <span class="comment">//ClassCastException</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>泛型类</strong></p><p>泛型类的定义格式：</p><ul><li><p>格式：修饰符 class 类名 &lt;类型&gt; { }</p></li><li><p>范例：public class Generic <T> { }</p><p>​此处的T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span> &lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        Generic&lt;String&gt; g1 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;();</span><br><span class="line">        g1.setT(<span class="string">&quot;李清霞&quot;</span>);</span><br><span class="line">        System.out.println(g1.getT());</span><br><span class="line">        Generic&lt;Integer&gt; g2 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;();</span><br><span class="line">        g2.setT(<span class="number">30</span>);</span><br><span class="line">        System.out.println(g2.getT());</span><br><span class="line">        Generic&lt;Boolean&gt; g3 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Boolean&gt;();</span><br><span class="line">        </span><br><span class="line">        g3.setT(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(g3.getT());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><mark>泛型类中的泛型成员不能直接实例化。</mark>它们的实例化必须通过相关方法的参数来传递给他们。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;  <span class="comment">//这里不能直接newT[]来实例化array</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(T[] tt)</span>&#123;</span><br><span class="line">        array = tt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一个泛型类，如果实例化时给予的实际具体类型不一样，那么这些实例类型是不兼容的，不能相互赋值。</li></ul><p><strong>泛型方法</strong></p><p>泛型方法的定义格式：</p><ul><li>格式：修饰符 &lt;类型&gt; 返回值类型 方法名 （类型 变量名）{ }</li><li>范例：public <T> void show( T t) { }</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>  &#123;</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">      System.out.println(t);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Generic</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>();</span><br><span class="line">      g.show(<span class="string">&quot;李清霞&quot;</span>);</span><br><span class="line">      g.show(<span class="number">100</span>);</span><br><span class="line">      g.show(<span class="literal">true</span>);</span><br><span class="line">      g.show(<span class="number">100.100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>泛型接口</strong></p><p>泛型接口的定义格式：</p><ul><li>格式：修饰符 interface 接口名 &lt;类型&gt; { }</li><li>范例：public interface Generic <T> { }</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generic</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Genericlmpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Generic&lt;String&gt; g1 = <span class="keyword">new</span> <span class="title class_">Genericlmpl</span>&lt;String&gt;();</span><br><span class="line">        g1.show(<span class="string">&quot;李清霞&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Generic&lt;Integer&gt; g2 = <span class="keyword">new</span> <span class="title class_">Genericlmpl</span>&lt;Integer&gt;();</span><br><span class="line">        g2.show(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>类型通配符</strong></p><p>为了表示各种泛型List的父类，可以使用通配符</p><ul><li>类型通配符：&lt;?&gt;</li><li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li><li>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li></ul><p>如果说我们不希望任何List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p><ul><li>类型通配符上限：&lt;? extends 类型&gt;</li><li>List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型</li></ul><p>除了可以指定类型通配符的上限，也可以指定类型通配符的下限</p><ul><li>类型通配符下限：&lt;? super 类型&gt;</li><li>List&lt;? super Number&gt;：它表示的类型是Number或者其父类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//类型通配符: &lt;?&gt;</span></span><br><span class="line">        List&lt;?&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        List&lt;?&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//类型通配符上限: &lt;? extends 类型&gt;</span></span><br><span class="line">        <span class="comment">//List&lt;? extends Integer&gt; list4 = new ArrayList&lt;Number&gt;(); 报错 Integer是Number的子类</span></span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//类型通配符下限: &lt;? super 类型&gt;</span></span><br><span class="line">        List&lt;? <span class="built_in">super</span> Integer&gt; list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;(); </span><br><span class="line">        List&lt;? <span class="built_in">super</span> Number&gt; list7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        <span class="comment">//List&lt;? super Number&gt; list8 = new ArrayList&lt;Integer&gt;();  报错 Integer是Number的子类</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>可变参数</strong></p><p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的</p><ul><li>格式：修饰符 返回值类型 方法名(数据类型… 变量名){ }</li><li>范例：public static int sum(int… a){ }</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"><span class="comment">//可变参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... a)</span>&#123;<span class="comment">//a相当于一个数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:a)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可变参数注意事项：</p><ul><li>这里的变量其实是一个数组</li><li>如果一个方法有多个参数，包含可变参数，<mark>可变参数要放最后</mark></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> b,<span class="type">int</span>... a)</span>&#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>可变参数的使用</strong></p><p>Arrays工具类中有一个静态方法：</p><ul><li>public static <T> List<T> asList(T… a);  返回由指定数组支持的固定大小的列表</li><li>返回的集合不能做增删操作，可以做修改操作</li></ul><p>List接口中有一个静态方法：</p><ul><li>public static <E> List<E> of(E… elements); 返回包含任意数量元素的不可变列表</li><li>返回的集合不能做增删改操作</li></ul><p>Set接口中有一个静态方法：</p><ul><li>public static <E> Set<E> of(E… elements); 返回一个包含任意数量元素的不可变集合</li><li>在给元素时，不能给重复的元素</li><li>返回的集合不能做增删操作，没有修改的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//public static &lt;T&gt; List&lt;T&gt; asList(T... a);  返回由指定数组支持的固定大小的列表</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//  list.add(&quot;javascript&quot;);  UnsupportedOperationException</span></span><br><span class="line">        <span class="comment">//  list.remove(&quot;java&quot;);    UnsupportedOperationException</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public static &lt;E&gt; List&lt;E&gt; of(E... elements); 返回包含任意数量元素的不可变列表</span></span><br><span class="line">        List&lt;String&gt; list2 = List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="comment">// list2.add(&quot;你好&quot;);  UnsupportedOperationException</span></span><br><span class="line">        <span class="comment">// list2.remove(&quot;world&quot;);  UnsupportedOperationException</span></span><br><span class="line">        <span class="comment">//  list2.set(2,&quot;你好&quot;);  UnsupportedOperationException</span></span><br><span class="line">        System.out.println(list2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public static &lt;E&gt; Set&lt;E&gt; of(E... elements); 返回一个包含任意数量元素的不可变集合</span></span><br><span class="line">       <span class="comment">// Set&lt;String&gt; set = Set.of(&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;,&quot;world&quot;); ImmutableCollections$SetN.&lt;init&gt;</span></span><br><span class="line">        Set&lt;String&gt; set = Set.of(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">       <span class="comment">// set.add(&quot;你好&quot;);  UnsupportedOperationException</span></span><br><span class="line">       <span class="comment">// set.remove(&quot;hello&quot;);  UnsupportedOperationException</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h2><p>异常就是代表程序出现的问题。其父类是 Throwable。其下两个子类，Error 和 Exception。Error 代表的是系统级别的错误（严重问题），是SUN公司自己用的。而 Exception 代表程序可能出现的问题。Exception 分为 RuntimeException 和其他异常。其中，<strong>RuntimeException 是运行时异常，编译阶段不会被检测出来，编译阶段 Java 不会执行代码，只会检查语法是否错误，或者做一些性能优化</strong>。<mark>编译时异常更多是提醒程序员检查本地信息，运行时异常是代码逻辑出错而导致程序出现的问题。</mark></p><p><mark>idea 当中使用 Ctrl + Alt + T 进行 try catch 包裹。</mark></p><p>Error：代表的系统级别错误(属于严重问题)</p><p>Exception：异常，代表程序可能出现的问题，通常用Exception以及它的子类来封装程序出现的问题。</p><p>运行时异常：RuntimeException及其子类，编译阶段不会出现异常提醒。运行时出现的异常(如：数组索引越界异常)</p><p>编译时异常：除了Exception及其子类，其他都是编译时异常。编译阶段就会出现异常提醒的。(如：日期解析异常)</p><p>编译阶段：java不会运行代码，只会检查语法错误，或者做一些性能的优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java文件</span><br><span class="line">   ⬇ Javac命令</span><br><span class="line">   字节码文件</span><br><span class="line">   ⬇ Java命令</span><br><span class="line">   运行结果</span><br><span class="line">   </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译时异常(在编译阶段，必必须手动处理，否则代码报错)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2023年12月18日&quot;</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(time);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行时异常(在编译阶段是不需要处理的，是代码运行时出现的异常)</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h3><ul><li>是用来查询bug的关键参考信息。</li><li>异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况<strong>（看异常的发生位置可以从下往上读）</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">18</span> || age &gt; <span class="number">40</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();   <span class="comment">//抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setAge(<span class="number">19</span>);</span><br><span class="line">        s1.setAge(<span class="number">17</span>);<span class="comment">//RuntimeException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h3><p>异常的常见处理方式有：</p><ol><li>JVM默认处理。</li><li>捕获异常。</li><li>抛出异常。</li></ol><p>其中，<strong>抛出</strong>主要是<strong>告诉调用者出错</strong>了。而<strong>捕获</strong>主要是为了<strong>不让程序停止</strong>。</p><h4 id="JVM默认处理"><a href="#JVM默认处理" class="headerlink" title="JVM默认处理"></a>JVM默认处理</h4><p>把异常的名称，异常原因以及异常出现的位置等信息用红色字体打印在控制台上。并且此时的程序停止，代码不再执行。</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>目的是让异常出现的时候，<strong>让程序继续执行</strong>。基本语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//可能出现异常的代码</span></span><br><span class="line">            System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line">            <span class="comment">//这里会创建ArrayIndexOutOfBoundsException的对象</span></span><br><span class="line">            <span class="comment">//与catch中的e对比，看看类型是否匹配，匹配了，就让程序继续进行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">//出现异常后该如何处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;索引越界了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;看看我执行了吗&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终执行的结果为：</span></span><br><span class="line">        <span class="comment">//索引越界了</span></span><br><span class="line">        <span class="comment">//看看我执行了吗</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于捕获异常的四个注意点：</p><ul><li><p><strong>如果 try 中没有遇到问题</strong>，会执行 try 当中的所有代码，不会执行 catch 的代码。也就是说，catch 当中的代码只有出现了了异常才会执行。</p></li><li><p><strong>如果 try 中遇到多个问题</strong>，如果第一个问题能够被顺利捕获，则<strong>接下来</strong> try 中代码便<strong>不会执行</strong>。最佳解决方案是写多个 catch 捕获多个问题（一行一个 catch或者一行中利用 <code>|</code> 连接），并且，如果异常之间有父子类关系的话，<strong>父类一定要写在下面</strong>。</p></li><li><p><strong>如果 try 中遇到的问题没有被捕获</strong>，则使用 JVM 默认处理异常的方式进行处理。</p></li><li><p><strong>如果 try 中遇到了问题</strong>，try 下面的其他代码便<strong>不会执行</strong>了，直接跳到 catch，但如果没有 catch 与之匹配，则按照 JVM 默认处理异常的方式进行处理。</p></li><li><p><strong>赋值运算符(&#x3D;)的关联性是从右到左，</strong>因此若一条赋值语句的左右两边都出现异常，则会先抛出等号右边的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exceptions2.ExDemo3.java</span></span><br><span class="line"><span class="keyword">package</span> exceptions2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arrayOfNumbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"> <span class="keyword">try</span> </span><br><span class="line"> &#123;</span><br><span class="line"> arrayOfNumbers[<span class="number">10</span>] = <span class="number">11</span>;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">catch</span> (NumberFormatException e1) </span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;NumberFormatException =&gt; &quot;</span> + e1.getMessage());</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">catch</span> (IndexOutOfBoundsException e2) </span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;IndexOutOfBoundsException =&gt; &quot;</span> + e2.getMessage());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> array[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">array[<span class="number">10</span>] = <span class="number">30</span> / <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException e) </span><br><span class="line">&#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) </span><br><span class="line">&#123;</span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">method2(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用method2方法时左边数组越界，右边除数为0，出现两个异常，但由于=的关联性是从右到左，因此会抛出右边的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><ul><li><strong>throws</strong>：写在方法定义处，表示声明一个异常。告诉调用者，使用本方法可能会有哪些异常。如果是编译时异常，必须要写，如果是运行时异常，可以不写。</li><li><strong>throw</strong>：写在方法内，结束方法。手动抛出异常对象，交给调用者。方法中下面的代码不在执行了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理时使用try catch捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sum = getSum(arr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;索引异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法求总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] number)</span> </span><br><span class="line">        <span class="keyword">throws</span> NullPointerException, ArrayIndexOutOfBoundsException &#123;    <span class="comment">//可以声明异常</span></span><br><span class="line">        <span class="keyword">if</span>(number == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();   <span class="comment">//也可以抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> index : number) &#123;</span><br><span class="line">            result += index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常中的常见方法"><a href="#异常中的常见方法" class="headerlink" title="异常中的常见方法"></a>异常中的常见方法</h3><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td><code>public String getMessage()</code></td><td>返回此 throwable 的详细消息字符串</td></tr><tr><td><code>public String toString()</code></td><td>返回此可抛出的简短描述</td></tr><tr><td><code>public void printStackTrace()</code></td><td>把异常的错误信息输出在控制台，<strong>但不停止虚拟机的运行</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">//Index 10 out of bounds for length 4</span></span><br><span class="line">            <span class="comment">//以上语句会打印异常的消息</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 4</span></span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();    <span class="comment">//打印操作，但实际不会停止虚拟机，因为第16行的测试代码会被成功打印</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;看看我执行了吗&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义异常的目的是为了让报错信息更加见名知意。步骤如下：</p><ol><li>定义异常类（编译时异常继承 Exception，运行时异常继承 RuntimeException）。</li><li>写继承关系。</li><li>空参构造。</li><li>带参构造。</li></ol><ul><li>如果try catch 语句中有返回值，并且语句中含有finally关键字，则return 后仍然会执行finally中的语句，<strong>即finally关键字包围的语句一定执行。</strong>return的如果是基本数据类型，则在finally块中不可以修改已返回的数据，如果是引用类型，则可以改变。</li></ul><h2 id="八、I-O流"><a href="#八、I-O流" class="headerlink" title="八、I&#x2F;O流"></a>八、I&#x2F;O流</h2><h3 id="8-1File"><a href="#8-1File" class="headerlink" title="8.1File"></a>8.1File</h3><p><strong>File类概述和构造方法</strong></p><p>File：它是文件和目录路径名的抽象表示</p><ul><li>文件和目录是可以通过File封装成对象的</li><li>对于File而言，其封装的并不是一个真正存在的文件，仅仅只是一个路径名。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转化为具体存在的</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>通过将给定的路径名字符串转化为抽象路径名来创建新的File实例</td></tr><tr><td>File(String parent，String child)</td><td>从父路径名字符串和子路径名字符串创建新的File实例</td></tr><tr><td>File(File parent，String child)</td><td>从父抽象路径名和子路径名字符串创建新的File实例</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//File(String pathname) 通过将给定的路径名字符串转化为抽象路径名来创建新的File实例</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//File(String parent，String child) 从父路径名字符串和子路径名字符串创建新的File实例</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA&quot;</span>,<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//File(File parent，String child) 从父抽象路径名和子路径名字符串创建新的File实例</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f3,<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>File类创建功能</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>当具有该名称的文件不存在时，创建一个由该抽象路径命名的新空文件</td></tr><tr><td>public boolean mkdir()</td><td>创建由此抽象路径命名的目录</td></tr><tr><td>public boolean mkdirs()</td><td>创建由此抽象路径命名的目录，包括任何必需但不存在的父目录</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//需求1:在D:\\IDEA目录下创建一个文件java.txt</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果文件不存在，就创建文件，返回true</span></span><br><span class="line"><span class="comment">        如果文件存在，就不创建文件，返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求2:在D:\\IDEA目录下创建一个目录JavaSE</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果目录不存在，就创建目录，返回true</span></span><br><span class="line"><span class="comment">        如果目录存在，就不创建目录，返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\JavaSE&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求3:在D:\\IDEA目录下创建一个多级目录JavaWEB\\HTML</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          如果目录不存在，就创建目录，返回true</span></span><br><span class="line"><span class="comment">        如果目录存在，就不创建目录，返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\JavaWEB\\HTML&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求4:在D:\\IDEA目录下创建一个文件Javase.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\javase.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(f4.mkdir());</span></span><br><span class="line">        System.out.println(f4.createNewFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>File类判断和获取功能</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean isDirectory()</td><td>测试此抽象路径名表示的File是否为目录</td></tr><tr><td>public boolean isFile()</td><td>测试此抽象路径名表示的File是否为文件</td></tr><tr><td>pblic boolean exists()</td><td>测试此抽象路径名表示的File是否存在</td></tr><tr><td>public String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>public String getPath()</td><td>将此抽象路径名转换为路径字符串</td></tr><tr><td>public String getName()</td><td>返回此抽象路径名表示的文件或者目录的名称</td></tr><tr><td>public String[] list()</td><td>返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</td></tr><tr><td>public File[] listFiles()</td><td>返回此抽象路径名表示的目录中的文件和目录中的File对象数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;protect\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.getAbsolutePath());<span class="comment">//绝对路径</span></span><br><span class="line">        System.out.println(f1.getPath());<span class="comment">//相对路径</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA&quot;</span>);</span><br><span class="line">        String[] strArray = f2.list();</span><br><span class="line">        <span class="keyword">for</span>(String str:strArray)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        File [] fileArray = f2.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file : fileArray)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(file);//会调用其toString方法</span></span><br><span class="line">            <span class="comment">//System.out.println(file.getName());</span></span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                System.out.println(file.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>File删除功能</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean delete()</td><td>删除由此抽象路径名表示的文件或目录</td></tr></tbody></table><p>绝对路径和相对路径的区别：</p><ul><li>绝对路径：<mark>完整的路径名</mark>，不需要任何其他信息就可以定位它所表示的文件。例如：D:\IDEA\java.txt</li><li>相对路径：必须使用取自其他路径名的信息进行解释。例如：IDEA\java.txt</li></ul><p>删除目录时的注意事项：</p><ul><li>如果一个目录中有内容(目录、文件)，<mark>不能直接删除</mark>，必须先删除目录中的内容，最后才能删除目录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一个文件</span></span><br><span class="line">        <span class="comment">// File f1= new File(&quot;D:\\IDEA\\java.txt&quot;);</span></span><br><span class="line">        <span class="comment">//需求1：在当前模块目录下创建java.txt文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求2：删除当前模块目录下的java.txt文件</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求3：在当前目录下创建itcast目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\itcast&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求4：删除当前模块下的itcast目录</span></span><br><span class="line">        System.out.println(f2.delete());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求5：在当前模块下创建一个目录itcast，然后在itcast目录下创建一个文件java.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\itcast&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA\\itcast\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.createNewFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求6：删除当前模块的目录itcast以及里面的文件java.txt</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果该目录下存在文件，则需要先将目录下的文件删除才能再将该目录删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line">        System.out.println(f3.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>案例：遍历目录</p><p>需求：给定一个路径(D:\IDEA)，请通过递归完成遍历该目录下的所有内容，并把所有内容的绝对路径输出在控制台</p><h2 id="九、反射"><a href="#九、反射" class="headerlink" title="九、反射"></a>九、反射</h2><p>反射允许对封装类的字段、方法和构造函数的信息进行编程访问</p><p><mark>IDEA中crtl+p能够弹出括号内需要的参数类型</mark></p><p>字段(成员变量)：获取修饰符、名字、类型，赋值&#x2F;获取值</p><p>构造方法：获取修饰符、名字、形参，创建对象</p><p>成员方法：获取修饰符、名字、形参、返回值，抛出的异常、获取注解、允许方法</p><h3 id="9-1获取class对象"><a href="#9-1获取class对象" class="headerlink" title="9.1获取class对象"></a>9.1获取class对象</h3><p>获取class对象的三种方式：</p><ul><li>Class.forName(“全类名”)；</li><li>类名.class</li><li>对象.getClass()；</li></ul><p><mark>源代码阶段</mark>：Java文件 A.java →  class文件 A.class    第一种方式</p><p><mark>加载阶段</mark>：将A.class放到内存中  第二种方式</p><p><mark>运行阶段</mark>：A a &#x3D; new ( )；第三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取class对象的三种方式：</span></span><br><span class="line"><span class="comment">        1 Class.forName(&quot;全类名&quot;)；</span></span><br><span class="line"><span class="comment">        2 类名.class</span></span><br><span class="line"><span class="comment">        3 对象.getClass()；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.Class.forName() 最为常用</span></span><br><span class="line">        <span class="comment">// 包名+类名</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflect.Student&quot;</span>);</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.类名.class 当作参数来进行传递</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.对象.getClass() 当我们有了这个对象时才可以使用</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line">        System.out.println(clazz == clazz3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java中万物皆对象，Java中有<mark>Class</mark>用来描述字节码文件，这个类的对象就是字节码文件的对象，有<mark>Constructor</mark>来描述构造方法，这个类的对象就表示这个构造方法的对象，<mark>Field</mark>用来描述字段(成员变量)，这个类的对象就是成员变量的对象，<mark>Method</mark>用来描述成员方法，这个类的对象就是成员方法的对象</p><h3 id="9-2利用反射获取构造方法"><a href="#9-2利用反射获取构造方法" class="headerlink" title="9.2利用反射获取构造方法"></a>9.2利用反射获取构造方法</h3><p><strong>Class类中用于获取构造方法的方法</strong></p><ul><li>Constructor&lt;?&gt;[] getConstructors()；返回所有公共构造方法对象的数组</li><li>Constructor&lt;?&gt;[] getDeclaredConstructors(); 返回所有构造方法对象的数组</li><li>Constructor<T> getConstructor(Class&lt;?&gt;…parameterTypes)；返回单个公共构造方法对象</li><li>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)；返回单个构造方法对象</li></ul><p><strong>Constructor类中用于创建对象的方法</strong></p><ul><li>T newInstance(Object… initargs)；根据指定的构造方法创建对象</li><li>setAccessible(boolean flag)；设置为true，表示取消访问检查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **Class类中用于获取构造方法的方法**</span></span><br><span class="line"><span class="comment">        - Constructor&lt;?&gt;[] getConstructors()；返回所有公共构造方法对象的数组</span></span><br><span class="line"><span class="comment">        - Constructor&lt;?&gt;[] getDeclaredConstructors(); 返回所有构造方法对象的数组</span></span><br><span class="line"><span class="comment">        - Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;...parameterTypes)；返回单个公共构造方法对象</span></span><br><span class="line"><span class="comment">        - Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)；返回单个构造方法对象</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        **Constructor类中用于创建对象的方法**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - T newInstance(Object... initargs)；根据指定的构造方法创建对象</span></span><br><span class="line"><span class="comment">        - setAccessible(boolean flag)；设置为true，表示取消访问检查</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取构造方法</span></span><br><span class="line">        Constructor[] cons = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor con : cons)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor[] cons2 = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor con : cons2)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con1</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        System.out.println(con1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        System.out.println(con2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(con3);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con4</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(con4);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> con4.getModifiers(); <span class="comment">// public: 1 protected: 4 private: 2  获取权限修饰符</span></span><br><span class="line">        System.out.println(modifiers);</span><br><span class="line"></span><br><span class="line">        Parameter[] parameters = con4.getParameters();<span class="comment">//获取参数</span></span><br><span class="line">        <span class="keyword">for</span>(Parameter parameter : parameters)&#123;</span><br><span class="line">            System.out.println(parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//暴力反射，表示临时取消权限校验</span></span><br><span class="line">        con4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)con4.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">14</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-3利用反射获取成员变量"><a href="#9-3利用反射获取成员变量" class="headerlink" title="9.3利用反射获取成员变量"></a>9.3利用反射获取成员变量</h3><p><strong>Class类中用于获取成员变量的方法</strong></p><ul><li>Field[] getFields()；返回所有公共成员变量对象的数组</li><li>Field[] getDeclaredFields()；返回所有成员变量对象的数组</li><li>Field getField(String name)；返回单个公共成员变量对象</li><li>Field getDeclaredField(String name)；返回单个成员变量对象</li></ul><p><strong>Filed类中用于创建对象的方法</strong></p><ul><li>void set(Object obj，Object value)；赋值</li><li>Object get(Object obj)；获取值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **Class类中用于获取成员变量的方法**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - Field[] getFields()；返回所有公共成员变量对象的数组</span></span><br><span class="line"><span class="comment">        - Field[] getDeclaredFields()；返回所有成员变量对象的数组</span></span><br><span class="line"><span class="comment">        - Field getField(String name)；返回单个公共成员变量对象</span></span><br><span class="line"><span class="comment">        - Field getDeclaredField(String name)；返回单个成员变量对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        **Filed类中用于创建对象的方法**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - void set(Object obj，Object value)；赋值</span></span><br><span class="line"><span class="comment">        - Object get(Object obj)；获取值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取成员变量</span></span><br><span class="line">        <span class="comment">//获取所有成员变量</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] fields2 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields2)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取单个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">gender</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">        System.out.println(gender);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifies</span> <span class="operator">=</span> name.getModifiers();</span><br><span class="line">        System.out.println(modifies);</span><br><span class="line">        <span class="type">int</span> <span class="variable">modifies2</span> <span class="operator">=</span> gender.getModifiers();</span><br><span class="line">        System.out.println(modifies2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员变量名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> name.getName();</span><br><span class="line">        System.out.println(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据类型</span></span><br><span class="line">        Class&lt;?&gt; type = name.getType();</span><br><span class="line">        System.out.println(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员变量的值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">29</span>);</span><br><span class="line">        <span class="comment">//临时取消权限检查</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> name.get(stu);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改成员变量的值</span></span><br><span class="line">      name.set(stu,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-4利用反射获取成员方法"><a href="#9-4利用反射获取成员方法" class="headerlink" title="9.4利用反射获取成员方法"></a>9.4利用反射获取成员方法</h3><p><strong>Class类中用于获取成员方法的方法</strong></p><ul><li>Method[] getMethods();返回所有公共成员方法对象的数组，<mark>包括继承的</mark></li><li>Method[] getDeclaredMethods();返回所有成员方法的数组，<mark>不包括继承的</mark></li><li>Method getMethod(String name,Class<T>… parameterTypes);返回单个公共成员对象方法</li><li>Method getDeclaredMethod(String name,Class<T>… parameterTypes);返回单个成员方法</li></ul><p><strong>Method类中用于创建对象的方法</strong></p><p>Object invoke(Object obj，Object… args); 运行方法</p><p>参数一：用obj对象调用方法</p><p>参数二：调用方法的传递参数(如果没有就不写)</p><p>返回值：方法的返回值(如果没有就不写)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **Class类中用于获取成员方法的方法**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - Method[] getMethods();返回所有公共成员方法对象的数组，&lt;mark&gt;包括继承的&lt;/mark&gt;</span></span><br><span class="line"><span class="comment">        - Method[] getDeclaredMethods();返回所有成员方法的数组，==不包括继承的==</span></span><br><span class="line"><span class="comment">        - Method getMethod(String name,Class&lt;T&gt;... parameterTypes);返回单个公共成员对象方法</span></span><br><span class="line"><span class="comment">        - Method getDeclaredMethod(String name,Class&lt;T&gt;... parameterTypes);返回单个成员方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        **Method类中用于创建对象的方法**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Object invoke(Object obj，Object... args); 运行方法</span></span><br><span class="line"><span class="comment">        参数一：用obj对象调用方法</span></span><br><span class="line"><span class="comment">        参数二：调用方法的传递参数(如果没有就不写)</span></span><br><span class="line"><span class="comment">        返回值：方法的返回值(如果没有就不写)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取成员方法</span></span><br><span class="line">        <span class="comment">//获取里面的所有公共成员方法对象(包括父类的所有公共方法)</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取里面的所有的成员方法(不能获取父类的，但是可以获取本类中的私有方法)</span></span><br><span class="line">        Method[] methods1 = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods1)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取单一指定方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        System.out.println(method1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifies</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line">        <span class="type">int</span> <span class="variable">modifies2</span> <span class="operator">=</span> method1.getModifiers();</span><br><span class="line">        System.out.println(modifies);</span><br><span class="line">        System.out.println(modifies2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> method1.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形参</span></span><br><span class="line">        Parameter[] parameters = method1.getParameters();</span><br><span class="line">        <span class="keyword">for</span>(Parameter parameter:parameters)&#123;</span><br><span class="line">            System.out.println(parameter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法抛出的异常</span></span><br><span class="line">        Class[] exceptionTypes = method1.getExceptionTypes();</span><br><span class="line">        <span class="keyword">for</span>(Class exceptionType:exceptionTypes)&#123;</span><br><span class="line">            System.out.println(exceptionType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法运行</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//参数一s:表示方法的调用者</span></span><br><span class="line">        <span class="comment">//参数二&quot;水果&quot;:表示在调用方法时传递的实际参数</span></span><br><span class="line">        method1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method1.invoke(s,<span class="string">&quot;水果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法的返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method1.invoke(s,<span class="string">&quot;水果&quot;</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>反射的作用</strong></p><ol><li>获取一个类里面的所有信息，获取到之后，再执行其他的业务逻辑</li><li>结合配置文件，动态的创建对象并调用方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/02/04/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/02/04/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图算法专题"><a href="#图算法专题" class="headerlink" title="图算法专题"></a>图算法专题</h1><h2 id="1、图的存储"><a href="#1、图的存储" class="headerlink" title="1、图的存储"></a>1、图的存储</h2><ul><li>邻接矩阵</li><li>邻接表</li></ul><p>邻接矩阵可以采用一个二维数组G[][]来进行存取数据，而邻接表可以采用链表形式或者vector数组来实现</p><p>一般来说对于点数较少的图采用邻接矩阵方式比较方便，而对于点数较多的密集图采用邻接表形式比较方便</p><h2 id="2、图的遍历"><a href="#2、图的遍历" class="headerlink" title="2、图的遍历"></a>2、图的遍历</h2><h3 id="深度优先搜素（DFS）"><a href="#深度优先搜素（DFS）" class="headerlink" title="深度优先搜素（DFS）"></a>深度优先搜素（DFS）</h3><ul><li>邻接矩阵版</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵版</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,G[N][N];<span class="comment">//n为顶点数，N为最大顶点数</span></span><br><span class="line"><span class="type">bool</span>  vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断该点是否被访问</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">10000000</span>;<span class="comment">//设INF为一个很大的数</span></span><br><span class="line"><span class="built_in">memset</span>(G,INF,<span class="keyword">sizeof</span>(G));<span class="comment">//初始化图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> depth)</span><span class="comment">//访问顶点u，depth为深度</span></span><br><span class="line">&#123;</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)<span class="comment">//枚举从u出发可以到达的所有顶点v</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<span class="comment">//如果v未被访问并且u可以到达v</span></span><br><span class="line">DFS(v,depth+<span class="number">1</span>);<span class="comment">//访问v,深度加1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS_Trave</span><span class="params">()</span><span class="comment">//遍历整个图G</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++)<span class="comment">//  访问每个顶点u</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)  <span class="comment">//如果u未被访问</span></span><br><span class="line">&#123;</span><br><span class="line">DFS(u,<span class="number">1</span>);  <span class="comment">//访问u和u所在的连通块，1为最开始的第一层</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>邻接表版</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n为顶点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;Adj [N];<span class="comment">//图G的邻接表</span></span><br><span class="line"><span class="type">bool</span>  vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断该点是否被访问</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">10000000</span>;<span class="comment">//设INF为一个很大的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> depth)</span><span class="comment">//访问顶点u，depth为深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]==<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="comment">/*如果需要对u进行一些操作，可以在此处进行*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Adj[u].<span class="built_in">size</span>();i++)<span class="comment">//枚举从u出发可以到达的所有顶点v</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v=Adj[u][i];</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)<span class="comment">//如果v未被访问</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DFS</span>(v,depth+<span class="number">1</span>);<span class="comment">//访问v,深度加1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_Trave</span><span class="params">()</span><span class="comment">//遍历整个图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++) <span class="comment">//对每个顶点u</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>) <span class="comment">//如果u未被访问</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DFS</span>(u,<span class="number">1</span>);  <span class="comment">//访问u和u的连通块，1表示初始为第一层</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜素（BFS）"><a href="#广度优先搜素（BFS）" class="headerlink" title="广度优先搜素（BFS）"></a>广度优先搜素（BFS）</h3><ol><li>邻接矩阵版</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 10000000</span></span><br><span class="line"><span class="type">int</span> n,G[N][N];<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已入队</span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>&amp;&amp;g[u][v]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v);</span><br><span class="line">vis[v]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTrave</span><span class="params">()</span><span class="comment">//遍历整个图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">BFS(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>邻接表版</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100000000</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;Adj[N];<span class="comment">//图G</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;Adj[u].size();v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> z=Adj[u][v];</span><br><span class="line"><span class="keyword">if</span>(vis[z]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(z);</span><br><span class="line">vis[z]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTrave</span><span class="params">()</span> <span class="comment">//遍历整个图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">BFS(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、拓扑排序"><a href="#3、拓扑排序" class="headerlink" title="3、拓扑排序"></a>3、拓扑排序</h2><p>时间复杂度O（n+m）,空间复杂度O（n） n为顶点数，m为边数</p><p>用途：</p><ol><li>计算工序最短用时（经典拓扑+dp）</li><li>有向无环图（DAG）判环</li><li>分级（排序、分层）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, x, index, ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];    <span class="comment">//邻接链表存图</span></span><br><span class="line"><span class="type">int</span> f[maxn], t[maxn];    <span class="comment">//记录总时长，单位时长</span></span><br><span class="line"><span class="type">int</span> indegree[maxn]; <span class="comment">//记录入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Topo_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!indegree[i]) &#123;  <span class="comment">//入度为0，入队</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            f[i] = t[i];  <span class="comment">//初始化时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//先计算该点的时间</span></span><br><span class="line">        <span class="type">int</span> temp = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            --indegree[G[temp][i]]; <span class="comment">//子节点的入度全部-1</span></span><br><span class="line">            f[G[temp][i]] = <span class="built_in">max</span>(f[G[temp][i]], f[temp] + t[G[temp][i]]); <span class="comment">//更新子节点的工序用时</span></span><br><span class="line">            <span class="keyword">if</span> (!indegree[G[temp][i]]) q.<span class="built_in">push</span>(G[temp][i]);   <span class="comment">//分层</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n; <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; index; <span class="comment">//工程序号</span></span><br><span class="line">        cin &gt;&gt; t[index];</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            G[x].<span class="built_in">push_back</span>(index);  <span class="comment">//建图</span></span><br><span class="line">            ++indegree[index];  <span class="comment">//入度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Topo_sort</span>();</span><br><span class="line">    <span class="comment">//找出最终答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAG判环：只需要新建一个cnt变量来记录队列中pop出来的顶点的个数，设总顶点数为N，若cnt&#x3D;&#x3D;N，则表明无环，若cnt!&#x3D;N，则表示有环。</p><p><strong>拓扑排序的稳定性</strong></p><p>拓扑排序时，若每一次入队的顶点数量均为1，则代表拓扑排序的结果只有一个，排序是稳定的；若每一次入队的顶点的数量不为1，则表示同一阶段有多个入度为0的顶点，这几个顶点的顺序是不固定的，故排序是不稳定的。<br>题目中若对排序有较严格要求，需要特别注意拓扑排序的稳定性。</p><h2 id="4、最短路径"><a href="#4、最短路径" class="headerlink" title="4、最短路径"></a>4、最短路径</h2><h3 id="Dijkstra算法（处理单源最短路径）"><a href="#Dijkstra算法（处理单源最短路径）" class="headerlink" title="Dijkstra算法（处理单源最短路径）"></a>Dijkstra算法（处理单源最短路径）</h3><p>​       Dijkstra算法用来解决单源最短路径问题，即给定一个图G和起点s，通过算法求出点s到达图中其他顶点的最短路径。其基本思想是对图G（V,E)设置集合S,存放已访问的顶点，然后每次从V-S中选择与顶点s最短距离最小的一个顶点（记为u)，访问并加入集合S。之后，令顶点u为中介点，优化起点s与所有从u所能到达的顶点v之间的最短距离。这样执行n次（n为顶点个数）,知道集合S中包含图中所有起点。</p><ul><li>邻接矩阵版</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100000000</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,G[N][N];<span class="comment">//顶点数 图G</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//记录起点s到达图中各顶点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断顶点是否访问</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span><span class="comment">//s起点</span></span><br><span class="line">&#123;</span><br><span class="line">   fill(d,d+N,INF);<span class="comment">//fill函数将整个d数组赋值为INF（慎用memset) </span></span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF的d[u]，说明剩下的顶点和s不连通</span></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果v未被访问并且u能到达v且能使得到达起点s的距离更小</span></span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF&amp;&amp;d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];<span class="comment">//松弛</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>邻接表版</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//顶点数 边数</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//记录起点s到达图中各顶点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断顶点是否访问</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> v;<span class="comment">//v为边的终点</span></span><br><span class="line">  <span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,INF,<span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Adj[N]; <span class="comment">//图G Adj[u]存放从顶点u出发可以到达的所有顶点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span><span class="comment">//s为起点</span></span><br><span class="line">&#123;</span><br><span class="line"> fill(d,d+N,INF);<span class="comment">//fill函数将整个d数组赋值为INF（慎用memset) </span></span><br><span class="line"> d[s]=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF的d[u]，说明剩下的顶点和s不连通</span></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;Adj[u][j].weight+d[u]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+Adj[u][j].weight;<span class="comment">//松弛</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">Node nd;</span><br><span class="line">nd.v=y;nd.weight=<span class="number">1</span>;<span class="comment">//边的权重</span></span><br><span class="line">Adj[x].push_back(nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Dijkstra(i);</span><br><span class="line"><span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">           <span class="keyword">if</span>(d[j]!=INF)</span><br><span class="line">           &#123;</span><br><span class="line">           maxn=max(j,maxn);<span class="comment">//找每个顶点能够到达的最大编号顶点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆优化版</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,u,v,w;<span class="comment">//顶点数 边数  源点</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//记录起点s到达图中各顶点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]= &#123;<span class="literal">false</span>&#125;; <span class="comment">//标记数组，判断顶点是否访问</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v;<span class="comment">//v为边的到达点</span></span><br><span class="line"><span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">v=a;</span><br><span class="line">weight=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt;Adj[N]; <span class="comment">//图G Adj[u]存放从顶点u出发可以到达的所有顶点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意优先级队列的优先级定义，小根堆要用大于号</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node n1,Node n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n1.weight==n2.weight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n1.v&gt;n2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> n1.weight&gt;n2.weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span><span class="comment">//s为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d,d+N,INF);<span class="comment">//fill函数将整个d数组赋值为INF（慎用memset)</span></span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt;q;<span class="comment">//优先级队列的自定义语法</span></span><br><span class="line"><span class="function">Node <span class="title">n1</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">q.<span class="built_in">push</span>(n1);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">Node M=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//特判两种情况</span></span><br><span class="line"><span class="keyword">if</span>(vis[M.v]==<span class="literal">true</span>)<span class="keyword">continue</span>;<span class="comment">//已访问过的结点不需要再访问</span></span><br><span class="line"><span class="keyword">if</span>(d[M.v]==INF)<span class="keyword">break</span>;<span class="comment">//不连通</span></span><br><span class="line">vis[M.v]=<span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> v=M.v;</span><br><span class="line"><span class="comment">//松弛</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; Adj[v].<span class="built_in">size</span>(); ++w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[Adj[v][w].v] &gt; d[v] + Adj[v][w].weight)</span><br><span class="line">&#123;</span><br><span class="line">d[Adj[v][w].v] = d[v] + Adj[v][w].weight;</span><br><span class="line"><span class="function">Node <span class="title">K</span><span class="params">(Adj[v][w].v, d[Adj[v][w].v])</span></span>;</span><br><span class="line">q.<span class="built_in">push</span>(K);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="function">Node <span class="title">temp</span><span class="params">(y,z)</span></span>;</span><br><span class="line">Adj[x].<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;d[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd算法（解决全源最短路径）"><a href="#Floyd算法（解决全源最短路径）" class="headerlink" title="Floyd算法（解决全源最短路径）"></a>Floyd算法（解决全源最短路径）</h3><p>该算法用于求任意两点之间的最短路径，也可以来求解一个点是否能到达另一个点。dis[][]数组用于存图。算法核心在于中转站的选择，意为在前v个中转站被允许参与中转的情况下，任意两点可以到达的最短路径，枚举中转站的时候也可以用来判断该点是否位于最短路径当中。注意先初始化dis[][]为INF。</p><p>求路径</p><p>Floyd算法可以多开一个path的二位数组来存放中转站标号，只需要在dp的时候在下面多加一句path[u][w]&#x3D;v;即可。<br>在求路径的时候需要用到递归。限制条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dis[i][j];</span><br><span class="line">        path[i][j] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Floyd算法求任意两点最短路径长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>; w &lt;= n; ++w) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[u][w] &gt; dis[u][v] + dis[v][w]) &#123;</span><br><span class="line">                dis[u][w] = min(dis[u][w], dis[u][v] + dis[v][w]);</span><br><span class="line">                <span class="comment">//  path[u][w]=v;   //记录路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (paht[u][v] == <span class="number">-1</span>) &#123;    <span class="comment">//u与v之间已经没有任何中转站，二者已经直接相连了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = path[u][v]; <span class="comment">//中转站</span></span><br><span class="line">        <span class="built_in">printPath</span>(u, mid);   <span class="comment">//左递归打印u到中转站的路径</span></span><br><span class="line">        <span class="built_in">printPath</span>(mid, v);   <span class="comment">//有递归打印中转站到v的路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>Bellman-Ford算法使用于求解单源最短路，该算法可以允许负权值边的存在。Bellman-Ford算法算法思想为进行n次松弛操作，每一次松弛操作都枚举每一条边，对该边的两端顶点路径长度进行修改。以此求出最短路径。时间复杂度为O（nm），其中n为顶点数，m为边数。</p><h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><p>SPFA（Shortest Path Faster Algorithm）算法，是Bellman-Ford算法的队列优化版，时间复杂度较为玄学，理论上讲SPFA可以对Bellman-Ford进行常数级别的优化，但是在算法竞赛当中可能出现卡SPFA时间复杂度使其时间复杂度退化为O（nm）的情况，对于不存在负权值边的图来讲，Dijkstra算法在优先队列优化过后效果稳定且时间复杂度优秀，优先选用Dijkstra。但是对于存在负权值边的图来讲，Dijkstra算法会失效，所以还得使用SPFA。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, a, b, w;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">vertex = v, weight = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vertex, weight;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; G[maxn];   <span class="comment">//邻接链表存图</span></span><br><span class="line"><span class="type">int</span> dis[maxn];  <span class="comment">//记录最终的距离数组</span></span><br><span class="line"><span class="type">bool</span> mark[maxn];<span class="comment">//记录顶点是否存在于队列之中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化距离为无穷大，原点为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">dis[start] = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">mark[start] = <span class="number">1</span>;<span class="comment">//该顶点已经入队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> v = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">mark[v] = <span class="number">0</span>;<span class="comment">//该顶点出队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G[v].<span class="built_in">size</span>(); ++w) &#123;  <span class="comment">//松弛</span></span><br><span class="line"><span class="keyword">if</span> (dis[G[v][w].vertex] &gt; dis[v] + G[v][w].weight) &#123;</span><br><span class="line">dis[G[v][w].vertex] = dis[v] + G[v][w].weight;</span><br><span class="line"><span class="keyword">if</span> (!mark[G[v][w].vertex]) &#123;<span class="comment">//可以松弛并且该顶点没有在队列里面</span></span><br><span class="line">mark[G[v][w].vertex] = <span class="number">1</span>;<span class="comment">//顶点入队并且进行mark的记录</span></span><br><span class="line">q.<span class="built_in">push</span>(G[v][w].vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5.最小生成树"></a>5.最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">        vertex = v, weight = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> vertex, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node n1, node n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1.weight &gt; n2.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, m, a, b, w, ans;</span><br><span class="line"><span class="type">bool</span> mark[maxn];<span class="comment">//标记数组</span></span><br><span class="line"><span class="type">int</span> dis[maxn];  <span class="comment">//存与顶点相连的边的长度</span></span><br><span class="line">vector&lt;node&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; q;</span><br><span class="line">    <span class="function">node <span class="title">N</span><span class="params">(start, <span class="number">0</span>)</span></span>;</span><br><span class="line">    q.<span class="built_in">push</span>(N);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node M = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span> (mark[M.vertex]) <span class="keyword">continue</span>;    <span class="comment">//已访问过的节点不需要再访问</span></span><br><span class="line">        <span class="keyword">if</span> (dis[M.vertex] == INF) <span class="keyword">break</span>;   <span class="comment">//图不连通</span></span><br><span class="line">        mark[M.vertex] = <span class="number">1</span>;   <span class="comment">//标记已访问</span></span><br><span class="line">        <span class="type">int</span> v = M.vertex;</span><br><span class="line">        <span class="comment">//松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">//需要特判是否重复选择</span></span><br><span class="line">            <span class="keyword">if</span> (dis[G[v][i].vertex] &gt; G[v][i].weight &amp;&amp; !mark[G[v][i].vertex]) &#123;</span><br><span class="line">                dis[G[v][i].vertex] = G[v][i].weight;</span><br><span class="line">                <span class="function">node <span class="title">P</span><span class="params">(G[v][i].vertex, G[v][i].weight)</span></span>;</span><br><span class="line">                q.<span class="built_in">push</span>(P);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;    <span class="comment">//创建边结构体</span></span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u, <span class="type">int</span> _v, <span class="type">int</span> _w) &#123;</span><br><span class="line">        u = _u, v = _v, w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge e1, edge e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.w &lt; e2.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, a, b, w, cnt, ans;</span><br><span class="line">vector&lt;edge&gt; E; <span class="comment">//存储图的所有边</span></span><br><span class="line"><span class="type">int</span> father[maxn];   <span class="comment">//并查集</span></span><br><span class="line"><span class="type">int</span> _find(<span class="type">int</span> s) &#123; <span class="comment">//查</span></span><br><span class="line">    <span class="keyword">while</span> (father[s] != s) s = father[s];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> s1, <span class="type">int</span> s2)</span> </span>&#123;    <span class="comment">//并</span></span><br><span class="line">    <span class="type">int</span> f1 = _find(s1), f2 = _find(s2);</span><br><span class="line">    father[<span class="built_in">max</span>(f1, f2)] = father[<span class="built_in">min</span>(f1, f2)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) father[i] = i;    <span class="comment">//初始化每一条边为自己的父亲</span></span><br><span class="line">    <span class="comment">//按照每一条边的权重排序</span></span><br><span class="line">    <span class="built_in">sort</span>(E.<span class="built_in">begin</span>(), E.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//枚举每一条边</span></span><br><span class="line">        <span class="type">int</span> _u = E[i].u, _v = E[i].v, _w = E[i].w;</span><br><span class="line">        <span class="keyword">if</span> (_find(_u) != _find(_v)) &#123;</span><br><span class="line">            cnt++;    <span class="comment">//计数器，如果最终cnt!=n-1则图不连通</span></span><br><span class="line">            ans += _w;</span><br><span class="line">            <span class="built_in">merge</span>(_u, _v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//全部的边找到了就截断函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、Tarjan算法"><a href="#6、Tarjan算法" class="headerlink" title="6、Tarjan算法"></a>6、Tarjan算法</h2><h3 id="强连通分量（Strongly-Connected-Components）"><a href="#强连通分量（Strongly-Connected-Components）" class="headerlink" title="强连通分量（Strongly Connected Components）"></a>强连通分量（Strongly Connected Components）</h3><ul><li><p>若有向图中有两个点 i 与 j 可以相互到达，则称这两个点强连通，如果图中任意两个点都强连通，则该图称为强连通图。任意一个点自己和自己是强连通的。</p></li><li><p>非强连通有向图的极大强连通子图称为该图的强连通分量。</p></li><li><p>根据定义，两个点一定是强连通的，当且仅当它们在同一个环内。环上所有的点都互相强连通。</p></li></ul><p><strong>算法思路</strong></p><p>该算法有两个数组比较重要，第一个是时间戳数组dfn[]，该数组是用来记录对应节点第一次被访问的顺序。另一个是追溯值数组low[]，该数组表示了从对应节点出发，所能够访问到的最早时间戳，以便方便我们进行强连通分量的判断。</p><p>算法分三步：</p><ol><li>入：指从 x 节点发起Tarjan算法时，记录 x 对应的时间戳，并将 x 入栈。</li><li>回：我们对 x 发起Tarjan算法，对 x 的子节点 y 进行遍历，分以下三种情况：<ul><li>如果 y 还未被访问，则继续对 y 进行深搜。回溯到 x 的时候，我们需要利用 y 的low值来更新 x 的low值。</li><li>如果 y 已经被访问并且 y 在栈中，说明了 y 是 x 的祖先节点或者左子树节点，这个时候我们直接利用 y 的dfn值来更新 x 的low值。</li><li>如果 y 已经访问并且不在栈中，表示 y 已经是属于另一个强连通分量，不需要对其进行其他处理了。</li></ul></li><li>离：在处理完 x 之后，判断 x 是否为一个强连通分量的入口，如果是，则出栈，并且记录相对应的强连通分量。</li><li>根据算法过程容易注意到，因为回溯，所以越往后搜索到的点强连通分量编号越靠前。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a, b, ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];<span class="comment">//邻接表存图</span></span><br><span class="line"><span class="type">bool</span> instk[maxn];<span class="comment">//判断元素是否在栈中</span></span><br><span class="line"><span class="type">int</span> stk[maxn], top;<span class="comment">//stk为手写栈，top为栈顶指针</span></span><br><span class="line"><span class="type">int</span> dfn[maxn], low[maxn], tot;<span class="comment">//时间戳，low值，对应的标记</span></span><br><span class="line"><span class="type">int</span> scc[maxn], siz[maxn], cnt;<span class="comment">//对应的节点属于哪一个强连通分量，对应的强连通分量的大小，强连通分量的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//入</span></span><br><span class="line">dfn[x] = low[x] = ++tot;<span class="comment">//初始化时间戳和追溯值</span></span><br><span class="line">stk[++top] = x, instk[x] = <span class="number">1</span>;<span class="comment">//元素入栈</span></span><br><span class="line"><span class="comment">//回</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="type">int</span> y = G[x][i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[y]) &#123;<span class="comment">//子节点没被访问，访问子节点</span></span><br><span class="line"><span class="built_in">Tarjan</span>(y);</span><br><span class="line">low[x] = <span class="built_in">min</span>(low[x], low[y]);<span class="comment">//利用子节点的追溯值来更新自己的追溯值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (instk[y]) &#123;<span class="comment">//子节点已经在栈中</span></span><br><span class="line">low[x] = <span class="built_in">min</span>(low[x], dfn[y]);<span class="comment">//子节点的时间戳来更新自己的追溯值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离</span></span><br><span class="line"><span class="keyword">if</span> (dfn[x] == low[x]) &#123;<span class="comment">//如果该节点是某一个SCC的入口，则对这个SCC进行处理</span></span><br><span class="line"><span class="type">int</span> tmp; ++cnt;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">tmp = stk[top--]; instk[tmp] = <span class="number">0</span>;<span class="comment">//取栈顶元素，出栈</span></span><br><span class="line">scc[tmp] = cnt;<span class="comment">//该顶点属于第cnt个SCC</span></span><br><span class="line">++siz[cnt];<span class="comment">//第cnt个SCC的大小加1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (tmp != x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i);<span class="comment">//如果这个顶点没被访问过，就从它开始发起Tarjan算法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (siz[i] &gt; <span class="number">1</span>) ++ans;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tarjan算法缩点"><a href="#Tarjan算法缩点" class="headerlink" title="Tarjan算法缩点"></a>Tarjan算法缩点</h3><p>Tarjan算法的缩点一般是在利用Tarjan算法求出SCC之后进行的操作，通常是对一个节点 i 访问它的子节点 j ，而后判断两个节点是否属于同一个SCC，如果不属于同一个SCC，则记录相应的入度出度，或者直接建新图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩点处理出度入度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (scc[i] != scc[G[i][j]]) &#123;</span><br><span class="line">din[scc[G[i][j]]]++;<span class="comment">//入度++</span></span><br><span class="line">dout[scc[i]]++;<span class="comment">//出度++</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩点建新图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (scc[i] != scc[G[i][j]])</span><br><span class="line">new_G[scc[i]].<span class="built_in">push_back</span>(scc[G[i][j]]);<span class="comment">//建新图</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、Hierholzer算法"><a href="#7、Hierholzer算法" class="headerlink" title="7、Hierholzer算法"></a>7、Hierholzer算法</h2><p>又称插入回路法，用于求解欧拉路和欧拉路径。</p><p>时间复杂度O（n+m），空间复杂度O（n），n为顶点数，m为边数。</p><p>求解欧拉路的时候需要提前判明该图是否存在欧拉路。判定条件如下：</p><p>有向图：</p><ul><li>欧拉回路：所有顶点出度入度一致。</li><li>欧拉路径：恰好有一个点的出度比入度多1（起点），恰好有一个点的入度比出度多1（终点）。</li></ul><p>无向图：</p><ul><li>欧拉回路：所有顶点的度数为偶数。</li><li>欧拉路径：恰好有两个顶点的度数为奇数。</li></ul><h3 id="有向图欧拉路"><a href="#有向图欧拉路" class="headerlink" title="有向图欧拉路"></a>有向图欧拉路</h3><p>接下来以邻接链表有向图的欧拉路求解算法进行演示（字典序最小的欧拉路）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> n, m, u, v, start = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">//判定图是否满足要求，默认满足欧拉图要求</span></span><br><span class="line"><span class="type">int</span> indegree[maxn], outdegree[maxn]; <span class="comment">//入度出度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];    <span class="comment">//邻接链表存图</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; ans; <span class="comment">//存路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge_path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;  <span class="comment">//出度比入度多的顶点个数，入度比出度多的顶点个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == outdegree[i]) <span class="keyword">continue</span>; <span class="comment">//出度入度相等</span></span><br><span class="line">        <span class="keyword">if</span> (indegree[i] + <span class="number">1</span> == outdegree[i]) &#123;   <span class="comment">//起点</span></span><br><span class="line">            cnt1++;</span><br><span class="line">            start = i;    <span class="comment">//记录起点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (indegree[i] == outdegree[i] + <span class="number">1</span>) cnt2++;    <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//其他条件不满足欧拉图要求</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!((cnt1 == <span class="number">1</span> &amp;&amp; cnt2 == <span class="number">1</span>) || (cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span>))) flag = <span class="literal">false</span>;   <span class="comment">//欧拉路径和欧拉回路情况判定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = G[s].<span class="built_in">begin</span>(); it != G[s].<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="type">int</span> next = *it;   <span class="comment">//取点</span></span><br><span class="line">        it = G[s].<span class="built_in">erase</span>(it);  <span class="comment">//删边</span></span><br><span class="line">        <span class="built_in">dfs</span>(next);  <span class="comment">//深搜继续</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push</span>(s);    <span class="comment">//无法再搜索了，此时记录节点，回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//点数和边数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);  <span class="comment">//建图</span></span><br><span class="line">        ++outdegree[u]; <span class="comment">//记录出度</span></span><br><span class="line">        ++indegree[v];  <span class="comment">//记录入度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">juede_path</span>();   <span class="comment">//判定该图是否为欧拉图</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> temp = ans.<span class="built_in">top</span>();</span><br><span class="line">        cout &lt;&lt; temp &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        ans.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无向图欧拉路"><a href="#无向图欧拉路" class="headerlink" title="无向图欧拉路"></a>无向图欧拉路</h3><p>无向图欧拉路，使用了并查集特判图是否连通。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="type">int</span> n, m, a, b, start = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">//默认满足欧拉图要求</span></span><br><span class="line"><span class="type">int</span> degree[maxn], father[maxn];    <span class="comment">//顶点的度，father为并查集，用于判断图是否连通</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;    <span class="comment">//边结构体，用于记录无向边的信息</span></span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u, <span class="type">int</span> _v) &#123; u = _u, v = _v; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(edge e1)<span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == e1.u) <span class="keyword">return</span> v &lt; e1.v;</span><br><span class="line">        <span class="keyword">return</span> u &lt; e1.u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;edge&gt; E;    <span class="comment">//储存边的信息</span></span><br><span class="line"><span class="type">int</span> _find(<span class="type">int</span> s) &#123;    <span class="comment">//查</span></span><br><span class="line">    <span class="keyword">while</span> (father[s] != s) s = father[s];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _merge(<span class="type">int</span> s1, <span class="type">int</span> s2) &#123;        <span class="comment">//并</span></span><br><span class="line">    <span class="type">int</span> f1 = _find(s1), f2 = _find(s2);</span><br><span class="line">    father[<span class="built_in">max</span>(f1, f2)] = father[<span class="built_in">min</span>(f1, f2)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge_path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;    <span class="comment">//初始化并查集数组</span></span><br><span class="line">        <span class="keyword">if</span> (degree[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;  <span class="comment">//度数为奇数的点</span></span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;edge&gt;::iterator it = E.<span class="built_in">begin</span>(); it != E.<span class="built_in">end</span>(); it++) &#123;    <span class="comment">//并</span></span><br><span class="line">        edge tmp = *it;</span><br><span class="line">        _merge(tmp.u, tmp.v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> f = _find(i);</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="number">1</span>) &#123;    <span class="comment">//判断图不连通</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(cnt == <span class="number">0</span> || cnt == <span class="number">2</span>)) flag = <span class="literal">false</span>;    <span class="comment">//度数有除了0和2以外的，不是欧拉图</span></span><br><span class="line"><span class="comment">//    if (cnt == 2 &amp;&amp; !(degree[1] &amp; 1)) flag = false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[start].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        edge _find(<span class="built_in">min</span>(start, G[start][i]), <span class="built_in">max</span>(start, G[start][i]));</span><br><span class="line">        set&lt;edge&gt;::iterator it = E.<span class="built_in">find</span>(_find);</span><br><span class="line">        <span class="keyword">if</span> (it != E.<span class="built_in">end</span>()) &#123;   <span class="comment">//边存在</span></span><br><span class="line">            E.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="built_in">dfs</span>(G[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push</span>(start);    <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        E.<span class="built_in">insert</span>(<span class="built_in">edge</span>(<span class="built_in">min</span>(a, b), <span class="built_in">max</span>(a, b)));    <span class="comment">//储存边</span></span><br><span class="line">        degree[a]++;</span><br><span class="line">        degree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">judge_path</span>();</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;    <span class="comment">//无法画出欧拉路</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//排序，保证路径的字典序最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(start);</span><br><span class="line">        <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> temp = ans.<span class="built_in">top</span>();</span><br><span class="line">            cout &lt;&lt; temp &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            ans.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学问题</title>
      <link href="/2024/02/03/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2024/02/03/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>快读</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>); ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一、高精度"><a href="#一、高精度" class="headerlink" title="一、高精度"></a>一、高精度</h2><h3 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//高精度加法计算</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2;</span><br><span class="line">    cin &gt;&gt; str1;<span class="comment">//输入第一个数</span></span><br><span class="line">    cin &gt;&gt; str2;<span class="comment">//输入第二个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">size</span>(); i ++)<span class="comment">//逆序输入</span></span><br><span class="line">        a[str1.<span class="built_in">size</span>()<span class="number">-1</span> - i] = str1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str2.<span class="built_in">size</span>(); i ++)<span class="comment">//逆序输入</span></span><br><span class="line">        b[str2.<span class="built_in">size</span>()<span class="number">-1</span> - i] = str2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        c[i+<span class="number">1</span>] += c[i] / <span class="number">10</span>;<span class="comment">//若大于10，进1</span></span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[len<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>)</span><br><span class="line">        len -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">        cout &lt;&lt; c[len<span class="number">-1</span>-i];<span class="comment">//逆序输出数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;    <span class="comment">//输入两个数字</span></span><br><span class="line"><span class="comment">//判断相减之后是否为负数</span></span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() || s1.<span class="built_in">size</span>() == s2.<span class="built_in">size</span>() &amp;&amp; s1 &lt; s2) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(s1, s2);    <span class="comment">//交换s1和s2，保证使用s1-s2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">max</span>(s1.<span class="built_in">size</span>(), s2.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    a[s1.<span class="built_in">size</span>() - <span class="number">1</span> - i] = s1[i] - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    b[s2.<span class="built_in">size</span>() - <span class="number">1</span> - i] = s2[i] - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理相减</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; b[i]) &#123; <span class="comment">//不够减向上借一位</span></span><br><span class="line">        a[i + <span class="number">1</span>]--;</span><br><span class="line">        a[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[i] = a[i] - b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除前导0</span></span><br><span class="line"><span class="keyword">while</span> (c[len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;   <span class="comment">//逆序输出</span></span><br><span class="line">    cout &lt;&lt; c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-高精度乘低精度"><a href="#3-高精度乘低精度" class="headerlink" title="3.高精度乘低精度"></a>3.高精度乘低精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N],b,c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;b;<span class="comment">//输入大数字 小数字</span></span><br><span class="line"><span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[len<span class="number">-1</span>-i]=s[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理相乘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]+=a[i]*b;</span><br><span class="line">c[i+<span class="number">1</span>]+=c[i]/<span class="number">10</span>;</span><br><span class="line">c[i]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求出数组最终长度</span></span><br><span class="line"><span class="keyword">while</span>(c[len]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c[len+<span class="number">1</span>]+=c[len]/<span class="number">10</span>;</span><br><span class="line">c[len]%=<span class="number">10</span>;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除前导0</span></span><br><span class="line"><span class="keyword">while</span>(c[len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;len&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//逆序输出</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-高精度乘高精度"><a href="#4-高精度乘高精度" class="headerlink" title="4.高精度乘高精度"></a>4.高精度乘高精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[s1.<span class="built_in">size</span>()<span class="number">-1</span>-i]=s1[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">b[s2.<span class="built_in">size</span>()<span class="number">-1</span>-i]=s2[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理相乘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s2.<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k=i+j;</span><br><span class="line">c[k]+=a[i]*b[j];</span><br><span class="line">c[k+<span class="number">1</span>]+=c[k]/<span class="number">10</span>;</span><br><span class="line">c[k]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断进位进到哪里，两个数相乘，位数最多是x+y位，所以从x+y+1位那里开始判断</span></span><br><span class="line"><span class="type">int</span> len=s1.<span class="built_in">size</span>()+s2.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(c[len<span class="number">-1</span>]&gt;<span class="number">0</span>)len++;</span><br><span class="line"><span class="comment">//删除前导0</span></span><br><span class="line"><span class="keyword">while</span>(c[len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;len&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;c[i];<span class="comment">//逆序输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-低精度除法高精商"><a href="#5-低精度除法高精商" class="headerlink" title="5.低精度除法高精商"></a>5.低精度除法高精商</h3><p>a除以b，要求输出小数点后n位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b, n, c[<span class="number">100</span>];</span><br><span class="line">c[<span class="number">0</span>] = a / b;   <span class="comment">//整数部分</span></span><br><span class="line"><span class="type">int</span> t = a % b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    c[i] = t * <span class="number">10</span> / b;</span><br><span class="line">    t = t * <span class="number">10</span> - c[i] * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先输出小数点前的数字以及小数点</span></span><br><span class="line">cout &lt;&lt; c[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="comment">//然后再来输出小数点后面的数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高精度除法低精度商"><a href="#6-高精度除法低精度商" class="headerlink" title="6.高精度除法低精度商"></a>6.高精度除法低精度商</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除数用s1存放，被除数用int b存放，余数用int t存放，商用s2存放</span></span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="type">int</span> b, t, x;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; b;</span><br><span class="line"><span class="comment">//高精度除法用正序转存s1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    a[i] = s1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//商暂时存在数组c中，长度存在int x中</span></span><br><span class="line">t = x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//代入计算的时候要注意余数t的参与</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    c[i] = (t * <span class="number">10</span> + a[i]) / b; <span class="comment">//记得加上上一个数作除法之后留下的余数</span></span><br><span class="line">    t = (t * <span class="number">10</span> + a[i]) % b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理前导0</span></span><br><span class="line"><span class="keyword">while</span> (c[x] == <span class="number">0</span> &amp;&amp; x &lt; s1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将商存到s2中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    s2 += c[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出商和余数</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t;</span><br></pre></td></tr></table></figure><h2 id="二、最大公约数与最小公倍数"><a href="#二、最大公约数与最小公倍数" class="headerlink" title="二、最大公约数与最小公倍数"></a>二、最大公约数与最小公倍数</h2><p>辗转相除法（欧几里得算法）最大公约数</p><p>时间复杂度为O（logb）</p><p>定理</p><p>当a与b都为正整数且a&gt;b时，记gcd(a,b)为a与b的最大公约数，则有gcd（a,b）&#x3D;gcd（b, a mod b）</p><p>证明</p><p>a可以表示成 a &#x3D; kb + r（a，b，k，r皆为正整数，且r不为0）</p><p>假设d是a，b的一个公约数，则有d|a，d|b，即a和b都可以被d整除。（x|y意为kx &#x3D; y，k为正整数）</p><p>而r &#x3D; a - kb，两边同时除以d，r&#x2F;d &#x3D; a&#x2F;d - kb&#x2F;d，由等式右边可知m &#x3D; r&#x2F;d为整数，因此d|r</p><p>因此d也是b，a mod b的公约数</p><p>故（a,b）与（b, a mod b）的公约数相等，则其最大公约数也相等，得证。</p><p>举例</p><p>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>1997 &#x2F; 615 &#x3D; 3 （余 152）<br>615 &#x2F; 152 &#x3D; 4（余7）<br>152 &#x2F; 7 &#x3D; 21（余5）<br>7 &#x2F; 5 &#x3D; 1 （余2）<br>5 &#x2F; 2 &#x3D; 2 （余1）<br>2 &#x2F; 1 &#x3D; 2 （余0）<br>至此，最大公约数为1。</p><h3 id="1-递归版"><a href="#1-递归版" class="headerlink" title="1.递归版"></a>1.递归版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-循环版"><a href="#2-循环版" class="headerlink" title="2.循环版"></a>2.循环版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>(a % b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       c = a % b;</span><br><span class="line">       a = b;</span><br><span class="line">       b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-内置函数"><a href="#3-内置函数" class="headerlink" title="3.内置函数"></a>3.内置函数</h3><p>C++可以使用内置函数__gcd（a,b）来求两数的最大公约数，使用时需包含头文件algorithm。</p><h3 id="4-求最大公倍数"><a href="#4-求最大公倍数" class="headerlink" title="4.求最大公倍数"></a>4.求最大公倍数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、素数筛法"><a href="#三、素数筛法" class="headerlink" title="三、素数筛法"></a>三、素数筛法</h2><h3 id="1-朴素筛法"><a href="#1-朴素筛法" class="headerlink" title="1.朴素筛法"></a>1.朴素筛法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-埃氏（Eratosthenes）筛法"><a href="#2-埃氏（Eratosthenes）筛法" class="headerlink" title="2.埃氏（Eratosthenes）筛法"></a>2.埃氏（Eratosthenes）筛法</h3><p>假设要筛2-n内的素数，则先将2的倍数从里面剔除，再将3的倍数从里面剔除，以此类推……（小学课本里面就已经记录了这种素数筛法，<del>这下我连小学生都不如了。。</del>）时间复杂度为O（nloglogn），已经非常接近线性了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//素数表获取</span></span><br><span class="line"><span class="comment">//埃式筛法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn],pnum=<span class="number">0</span>;<span class="comment">//数组来记录素数元素，pnum来记录素数个数</span></span><br><span class="line"><span class="type">bool</span> p[maxn];<span class="comment">//素数判断 false 则说明为素数，否则不为素数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">prime[pnum++]=i;<span class="comment">//记录素数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;maxn;j+=i)<span class="comment">//将素数的倍数标记为非素数</span></span><br><span class="line">&#123;</span><br><span class="line">p[j]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find_prime</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-欧拉（Euler）筛法"><a href="#3-欧拉（Euler）筛法" class="headerlink" title="3.欧拉（Euler）筛法"></a>3.欧拉（Euler）筛法</h3><p>欧拉筛法是埃氏筛法的改进，埃氏筛法终究会出现一个数被多个数筛掉的情况。例如因为120 &#x3D; 2^3 x 3 x 5，因为2，3，5是120的质因子，所以120会被2筛一次，被3筛一次，被5筛一次，共3次。</p><p>而欧拉筛法保证了每一个合数都被其最小质因子筛去，保证不会重复筛除。故遍历一次就好，时间复杂度为O（n）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//欧拉筛法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">bool</span> p[N];<span class="comment">//素数判断 false为素数 </span></span><br><span class="line"><span class="type">int</span> prime[N],pnum=<span class="number">0</span>;<span class="comment">//数组记录素数元素，pnum记录素数个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">prime[pnum++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;pnum&amp;&amp;i*prime[j]&lt;=N;j++)<span class="comment">//防止数组越界</span></span><br><span class="line">&#123;</span><br><span class="line">p[i*prime[j]]=<span class="literal">true</span>;<span class="comment">//最小质因子筛合数</span></span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find_prime</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、分数计算"><a href="#四、分数计算" class="headerlink" title="四、分数计算"></a>四、分数计算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分数运算</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span><span class="comment">//分数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> up;<span class="comment">//分子</span></span><br><span class="line"><span class="type">int</span> down;<span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//约分</span></span><br><span class="line"><span class="function">Frac <span class="title">reduction</span><span class="params">(Frac result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(result.down&lt;<span class="number">0</span>)<span class="comment">//分母为负数，分子分母变相反数</span></span><br><span class="line">&#123;</span><br><span class="line">result.up=-result.up;<span class="comment">//符号位放在分母上</span></span><br><span class="line">     result.down=-result.down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(result.up==<span class="number">0</span>)<span class="comment">//分子为0</span></span><br><span class="line">&#123;</span><br><span class="line">result.down=<span class="number">1</span>;<span class="comment">//分母为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> d=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(result.up),<span class="built_in">abs</span>(result.down));<span class="comment">//约分</span></span><br><span class="line">result.up/=d;</span><br><span class="line">result.down/=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function">Frac <span class="title">multi</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.up;</span><br><span class="line">result.down=f1.down*f2.down;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="function">Frac <span class="title">divide</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.down;</span><br><span class="line">result.down=f1.down*f2.up;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function">Frac <span class="title">add</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.down+f1.down*f2.up;</span><br><span class="line">result.down=f1.down*f2.down;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function">Frac <span class="title">minu</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.down-f1.down*f2.up;</span><br><span class="line">result.down=f1.down*f2.down;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Frac r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">r=<span class="built_in">reduction</span>(r);</span><br><span class="line"><span class="keyword">if</span>(r.down==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r.up);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(r.up)&gt;r.down)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d/%d\n&quot;</span>,r.up/r.down,<span class="built_in">abs</span>(r.up)%r.down,r.down);<span class="comment">//假分数表示形式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>,r.up,r.down);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b,c,d;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">Frac f,e,r;</span><br><span class="line">f.up=a;e.up=c;</span><br><span class="line">f.down=b;e.down=d;</span><br><span class="line"><span class="built_in">show</span>(f);</span><br><span class="line"><span class="built_in">show</span>(e);</span><br><span class="line">r=<span class="built_in">add</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line">r=<span class="built_in">minu</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line">r=<span class="built_in">multi</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line">r=<span class="built_in">divide</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、前缀和"><a href="#五、前缀和" class="headerlink" title="五、前缀和"></a>五、前缀和</h2><p>1.一维前缀和</p><p>dp[i]表示从下标1开始到下标i的一维数组元素之和，若计算区间[a,b]的数组元素之和，其中递推式sum&#x3D;dp[j]-dp[i-1].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> arr[N],dp[N];<span class="comment">//dp[i]表示从下标1开始到下标i的数组元素之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i]=dp[i<span class="number">-1</span>]+arr[i];<span class="comment">//计算前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.二维前缀和</p><p>s(i,j)表示从（1,1)开始到（i，j)位置的二维数组所有元素之和，其中递推式为s(i,j)+&#x3D;s(i-1,j)+s(i,j-1)-s(i-1,j-1),则从（a+1,b+1)到（c，d)的和为s[a,b]+s[c,d]-s[a,d]-s[b,c].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line"><span class="comment">//s[i][j]表示从arr[1][1]到arr[i][j]的和</span></span><br><span class="line"><span class="type">int</span> n,l,r,t,arr[<span class="number">605</span>][<span class="number">605</span>],count,sum[<span class="number">605</span>][<span class="number">605</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 16 1 6</span></span><br><span class="line"><span class="comment">0 1 2 3</span></span><br><span class="line"><span class="comment">4 5 6 7</span></span><br><span class="line"><span class="comment">8 9 10 11</span></span><br><span class="line"><span class="comment">12 13 14 15</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> sumval=<span class="number">0</span>;<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left=<span class="built_in">max</span>(<span class="number">1</span>,x-r),right=<span class="built_in">min</span>(n,x+r);<span class="comment">//左右边界</span></span><br><span class="line"><span class="type">int</span> down=<span class="built_in">max</span>(<span class="number">1</span>,y-r),up=<span class="built_in">min</span>(n,y+r);<span class="comment">//上下边界</span></span><br><span class="line">sumval = sum[right][up] - sum[right][down<span class="number">-1</span>] - sum[left<span class="number">-1</span>][up] + sum[left<span class="number">-1</span>][down<span class="number">-1</span>];</span><br><span class="line">num=(right-left+<span class="number">1</span>)*(up-down+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> ave=sumval*<span class="number">1.00</span>/num;</span><br><span class="line"><span class="keyword">if</span>(ave&lt;=t)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;arr[i][j];<span class="comment">//读入数据</span></span><br><span class="line">sum[i][j]=arr[i][j];</span><br><span class="line">sum[i][j] += sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] ;<span class="comment">//计算前缀和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">judge</span>(i,j))count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、差分"><a href="#六、差分" class="headerlink" title="六、差分"></a>六、差分</h2><p>差分是求前缀和的逆操作，对于原数组a[n],构造出一个b[n]数组中，使a[n]为b[n]的前缀和。一般用于快速对整个数组进行操作，比如将a数组中[l,r]部分的数据全部加上c.使用暴力的方法，则时间复杂度至少为O（n),而使用差分算法时间复杂度降低到O（1）.</p><p><strong>1.一维差分</strong><br>创建一数组b，使得数组a为数组b的前缀和，数组b为数组a的差分</p><p>构造方法：b[i] &#x3D; a[i] - a[i - 1]</p><p>此处使用了一个虚拟的构造方式(在数组一个位置加上一个数，那么在它的下一个位置减去这一数)</p><p>应用：对于a数组的任意区间[l, r]，令其加上一个数，而不改变其它值</p><p>b[l] +&#x3D; c, b[r + 1] -&#x3D; c</p><p>差分操作和前缀和一样数组下标都从1开始。</p><p>b[l]+c后，l后面的数组都会加c。r后面的数据也会被改变，要改回来就得b[r+1]-c.</p><p><strong>模板题如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">输入一个长度为 n 的整数序列。接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。</span><br><span class="line">请你输出进行完所有操作后的序列。输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。</span><br><span class="line">第二行包含 n 个整数，表示整数序列。</span><br><span class="line">接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。输出格式</span><br><span class="line">共一行，包含 n 个整数，表示最终序列。数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤l≤r≤n,</span><br><span class="line">−<span class="number">1000</span>≤c≤<span class="number">1000</span>,</span><br><span class="line">−<span class="number">1000</span>≤整数序列中元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )cin&gt;&gt;a[i];<span class="comment">//读入数据</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        b[j]=a[j]-a[j<span class="number">-1</span>];<span class="comment">//进行差分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        b[l]=b[l]+c;</span><br><span class="line">        b[r+<span class="number">1</span>]=b[r+<span class="number">1</span>]-c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        sum=sum+b[i];</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.二维差分</strong><br>直接得出公式<code>b[i][j] += c, b[i + 1][j] -= c, b[i][j + 1] -= c, b[i + 1][j + 1] += c</code><br>每次对b数组执行以上操作，等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=x1;i&lt;=x2;i++)</span><br><span class="line">  <span class="keyword">for</span>(int j=y1;j&lt;=y2;j++)</span><br><span class="line">    a[i][j]+=c;</span><br></pre></td></tr></table></figure><p><strong>模板题如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</span><br><span class="line">每个操作都要将选中的子矩阵中的每个元素的值加上 c。</span><br><span class="line">请你将进行完所有操作后的矩阵输出。输入格式</span><br><span class="line">第一行包含整数 n,m,q。</span><br><span class="line">接下来 n 行，每行包含 m 个整数，表示整数矩阵。</span><br><span class="line">接下来 q 行，每行包含 <span class="number">5</span> 个整数 x1,y1,x2,y2,c，表示一个操作。</span><br><span class="line">输出格式</span><br><span class="line">共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤x1≤x2≤n,</span><br><span class="line"><span class="number">1</span>≤y1≤y2≤m,</span><br><span class="line">−<span class="number">1000</span>≤c≤<span class="number">1000</span>,</span><br><span class="line">−<span class="number">1000</span>≤矩阵内元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);      <span class="comment">//构建差分数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//二维前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">           cout&lt;&lt;b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="七、扩展欧几里得算法"><a href="#七、扩展欧几里得算法" class="headerlink" title="七、扩展欧几里得算法"></a>七、扩展欧几里得算法</h2><p>给定两个整数a和b，求一组整数解（x,y)使得ax+by&#x3D;gcd(a,b)成立，其中gcd(a,b)表示a和b的最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">exgcd</span>(b,a%b,x,y);<span class="comment">//递归计算exgcd(b,a%b)</span></span><br><span class="line">    <span class="type">int</span> temp=x;<span class="comment">//存放x的值</span></span><br><span class="line">    x=y;<span class="comment">//更新x=y(old)</span></span><br><span class="line">    y=temp-a/b*y;  <span class="comment">//更新y=x(old)-a/b*y(old)</span></span><br><span class="line">    <span class="keyword">return</span> g;  <span class="comment">//g是gcd</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、进制转换"><a href="#八、进制转换" class="headerlink" title="八、进制转换"></a>八、进制转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//进制转化</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp1;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">char</span>&gt;mp2;</span><br><span class="line"><span class="type">int</span> num,temp;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">mp1[i+<span class="string">&#x27;0&#x27;</span>]=i;</span><br><span class="line">mp2[i]=i+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;F&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">mp1[i]=i-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">mp2[i-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d;<span class="comment">//初始进制</span></span><br><span class="line">cin&gt;&gt;d;</span><br><span class="line">string str;<span class="comment">//读入数据</span></span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//转化为10进制</span></span><br><span class="line">temp=temp*d+mp1[str[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;<span class="comment">//转化后的进制</span></span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">while</span>(temp)</span><br><span class="line">&#123;</span><br><span class="line">ans[num++]=mp2[temp%a];</span><br><span class="line">temp/=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、组合数求解"><a href="#九、组合数求解" class="headerlink" title="九、组合数求解"></a>九、组合数求解</h2><p>公式：<br>$$<br>C_n^m&#x3D;1(m&#x3D;0或m&#x3D;n)\<br>c_n^m&#x3D;c_{n-1}^m+c_{n-1}^{m-1}(n&gt;m&gt;0)<br>$$</p><p>所以，我们可以使用动态规划来求解组合数，直接上代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    dp[i][i] = dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到每一行的组合数都只需要用到上一行组合数的数值，所以可以进行<strong>状态压缩</strong>，注意倒序处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;    <span class="comment">//倒序处理</span></span><br><span class="line">        <span class="keyword">if</span> (j == i || j == <span class="number">0</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
