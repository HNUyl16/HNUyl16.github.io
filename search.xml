<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图论</title>
      <link href="/2024/02/04/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/02/04/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图算法专题"><a href="#图算法专题" class="headerlink" title="图算法专题"></a>图算法专题</h1><h2 id="1、图的存储"><a href="#1、图的存储" class="headerlink" title="1、图的存储"></a>1、图的存储</h2><ul><li>邻接矩阵</li><li>邻接表</li></ul><p>邻接矩阵可以采用一个二维数组G[][]来进行存取数据，而邻接表可以采用链表形式或者vector数组来实现</p><p>一般来说对于点数较少的图采用邻接矩阵方式比较方便，而对于点数较多的密集图采用邻接表形式比较方便</p><h2 id="2、图的遍历"><a href="#2、图的遍历" class="headerlink" title="2、图的遍历"></a>2、图的遍历</h2><h3 id="深度优先搜素（DFS）"><a href="#深度优先搜素（DFS）" class="headerlink" title="深度优先搜素（DFS）"></a>深度优先搜素（DFS）</h3><ul><li>邻接矩阵版</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵版</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,G[N][N];<span class="comment">//n为顶点数，N为最大顶点数</span></span><br><span class="line"><span class="type">bool</span>  vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断该点是否被访问</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">10000000</span>;<span class="comment">//设INF为一个很大的数</span></span><br><span class="line"><span class="built_in">memset</span>(G,INF,<span class="keyword">sizeof</span>(G));<span class="comment">//初始化图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> depth)</span><span class="comment">//访问顶点u，depth为深度</span></span><br><span class="line">&#123;</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)<span class="comment">//枚举从u出发可以到达的所有顶点v</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<span class="comment">//如果v未被访问并且u可以到达v</span></span><br><span class="line">DFS(v,depth+<span class="number">1</span>);<span class="comment">//访问v,深度加1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS_Trave</span><span class="params">()</span><span class="comment">//遍历整个图G</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++)<span class="comment">//  访问每个顶点u</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)  <span class="comment">//如果u未被访问</span></span><br><span class="line">&#123;</span><br><span class="line">DFS(u,<span class="number">1</span>);  <span class="comment">//访问u和u所在的连通块，1为最开始的第一层</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>邻接表版</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n为顶点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;Adj [N];<span class="comment">//图G的邻接表</span></span><br><span class="line"><span class="type">bool</span>  vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断该点是否被访问</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">10000000</span>;<span class="comment">//设INF为一个很大的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> depth)</span><span class="comment">//访问顶点u，depth为深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]==<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="comment">/*如果需要对u进行一些操作，可以在此处进行*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Adj[u].<span class="built_in">size</span>();i++)<span class="comment">//枚举从u出发可以到达的所有顶点v</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v=Adj[u][i];</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)<span class="comment">//如果v未被访问</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DFS</span>(v,depth+<span class="number">1</span>);<span class="comment">//访问v,深度加1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_Trave</span><span class="params">()</span><span class="comment">//遍历整个图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++) <span class="comment">//对每个顶点u</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>) <span class="comment">//如果u未被访问</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DFS</span>(u,<span class="number">1</span>);  <span class="comment">//访问u和u的连通块，1表示初始为第一层</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜素（BFS）"><a href="#广度优先搜素（BFS）" class="headerlink" title="广度优先搜素（BFS）"></a>广度优先搜素（BFS）</h3><ol><li>邻接矩阵版</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 10000000</span></span><br><span class="line"><span class="type">int</span> n,G[N][N];<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已入队</span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>&amp;&amp;g[u][v]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v);</span><br><span class="line">vis[v]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTrave</span><span class="params">()</span><span class="comment">//遍历整个图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">BFS(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>邻接表版</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100000000</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;Adj[N];<span class="comment">//图G</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;Adj[u].size();v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> z=Adj[u][v];</span><br><span class="line"><span class="keyword">if</span>(vis[z]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(z);</span><br><span class="line">vis[z]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTrave</span><span class="params">()</span> <span class="comment">//遍历整个图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">BFS(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、拓扑排序"><a href="#3、拓扑排序" class="headerlink" title="3、拓扑排序"></a>3、拓扑排序</h2><p>时间复杂度O（n+m）,空间复杂度O（n） n为顶点数，m为边数</p><p>用途：</p><ol><li>计算工序最短用时（经典拓扑+dp）</li><li>有向无环图（DAG）判环</li><li>分级（排序、分层）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, x, index, ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];    <span class="comment">//邻接链表存图</span></span><br><span class="line"><span class="type">int</span> f[maxn], t[maxn];    <span class="comment">//记录总时长，单位时长</span></span><br><span class="line"><span class="type">int</span> indegree[maxn]; <span class="comment">//记录入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Topo_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!indegree[i]) &#123;  <span class="comment">//入度为0，入队</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            f[i] = t[i];  <span class="comment">//初始化时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//先计算该点的时间</span></span><br><span class="line">        <span class="type">int</span> temp = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[temp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            --indegree[G[temp][i]]; <span class="comment">//子节点的入度全部-1</span></span><br><span class="line">            f[G[temp][i]] = <span class="built_in">max</span>(f[G[temp][i]], f[temp] + t[G[temp][i]]); <span class="comment">//更新子节点的工序用时</span></span><br><span class="line">            <span class="keyword">if</span> (!indegree[G[temp][i]]) q.<span class="built_in">push</span>(G[temp][i]);   <span class="comment">//分层</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n; <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; index; <span class="comment">//工程序号</span></span><br><span class="line">        cin &gt;&gt; t[index];</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            G[x].<span class="built_in">push_back</span>(index);  <span class="comment">//建图</span></span><br><span class="line">            ++indegree[index];  <span class="comment">//入度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Topo_sort</span>();</span><br><span class="line">    <span class="comment">//找出最终答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAG判环：只需要新建一个cnt变量来记录队列中pop出来的顶点的个数，设总顶点数为N，若cnt&#x3D;&#x3D;N，则表明无环，若cnt!&#x3D;N，则表示有环。</p><p><strong>拓扑排序的稳定性</strong></p><p>拓扑排序时，若每一次入队的顶点数量均为1，则代表拓扑排序的结果只有一个，排序是稳定的；若每一次入队的顶点的数量不为1，则表示同一阶段有多个入度为0的顶点，这几个顶点的顺序是不固定的，故排序是不稳定的。<br>题目中若对排序有较严格要求，需要特别注意拓扑排序的稳定性。</p><h2 id="4、最短路径"><a href="#4、最短路径" class="headerlink" title="4、最短路径"></a>4、最短路径</h2><h3 id="Dijkstra算法（处理单源最短路径）"><a href="#Dijkstra算法（处理单源最短路径）" class="headerlink" title="Dijkstra算法（处理单源最短路径）"></a>Dijkstra算法（处理单源最短路径）</h3><p>​       Dijkstra算法用来解决单源最短路径问题，即给定一个图G和起点s，通过算法求出点s到达图中其他顶点的最短路径。其基本思想是对图G（V,E)设置集合S,存放已访问的顶点，然后每次从V-S中选择与顶点s最短距离最小的一个顶点（记为u)，访问并加入集合S。之后，令顶点u为中介点，优化起点s与所有从u所能到达的顶点v之间的最短距离。这样执行n次（n为顶点个数）,知道集合S中包含图中所有起点。</p><ul><li>邻接矩阵版</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100000000</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,G[N][N];<span class="comment">//顶点数 图G</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//记录起点s到达图中各顶点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断顶点是否访问</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span><span class="comment">//s起点</span></span><br><span class="line">&#123;</span><br><span class="line">   fill(d,d+N,INF);<span class="comment">//fill函数将整个d数组赋值为INF（慎用memset) </span></span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF的d[u]，说明剩下的顶点和s不连通</span></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果v未被访问并且u能到达v且能使得到达起点s的距离更小</span></span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF&amp;&amp;d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];<span class="comment">//松弛</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>邻接表版</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//顶点数 边数</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//记录起点s到达图中各顶点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//标记数组，判断顶点是否访问</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> v;<span class="comment">//v为边的终点</span></span><br><span class="line">  <span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,INF,<span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Adj[N]; <span class="comment">//图G Adj[u]存放从顶点u出发可以到达的所有顶点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span><span class="comment">//s为起点</span></span><br><span class="line">&#123;</span><br><span class="line"> fill(d,d+N,INF);<span class="comment">//fill函数将整个d数组赋值为INF（慎用memset) </span></span><br><span class="line"> d[s]=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF的d[u]，说明剩下的顶点和s不连通</span></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;Adj[u][j].weight+d[u]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+Adj[u][j].weight;<span class="comment">//松弛</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">Node nd;</span><br><span class="line">nd.v=y;nd.weight=<span class="number">1</span>;<span class="comment">//边的权重</span></span><br><span class="line">Adj[x].push_back(nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Dijkstra(i);</span><br><span class="line"><span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">           <span class="keyword">if</span>(d[j]!=INF)</span><br><span class="line">           &#123;</span><br><span class="line">           maxn=max(j,maxn);<span class="comment">//找每个顶点能够到达的最大编号顶点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆优化版</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,u,v,w;<span class="comment">//顶点数 边数  源点</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//记录起点s到达图中各顶点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]= &#123;<span class="literal">false</span>&#125;; <span class="comment">//标记数组，判断顶点是否访问</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v;<span class="comment">//v为边的到达点</span></span><br><span class="line"><span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">v=a;</span><br><span class="line">weight=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt;Adj[N]; <span class="comment">//图G Adj[u]存放从顶点u出发可以到达的所有顶点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意优先级队列的优先级定义，小根堆要用大于号</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node n1,Node n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n1.weight==n2.weight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n1.v&gt;n2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> n1.weight&gt;n2.weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span><span class="comment">//s为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d,d+N,INF);<span class="comment">//fill函数将整个d数组赋值为INF（慎用memset)</span></span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt;q;<span class="comment">//优先级队列的自定义语法</span></span><br><span class="line"><span class="function">Node <span class="title">n1</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">q.<span class="built_in">push</span>(n1);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">Node M=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//特判两种情况</span></span><br><span class="line"><span class="keyword">if</span>(vis[M.v]==<span class="literal">true</span>)<span class="keyword">continue</span>;<span class="comment">//已访问过的结点不需要再访问</span></span><br><span class="line"><span class="keyword">if</span>(d[M.v]==INF)<span class="keyword">break</span>;<span class="comment">//不连通</span></span><br><span class="line">vis[M.v]=<span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> v=M.v;</span><br><span class="line"><span class="comment">//松弛</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; Adj[v].<span class="built_in">size</span>(); ++w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[Adj[v][w].v] &gt; d[v] + Adj[v][w].weight)</span><br><span class="line">&#123;</span><br><span class="line">d[Adj[v][w].v] = d[v] + Adj[v][w].weight;</span><br><span class="line"><span class="function">Node <span class="title">K</span><span class="params">(Adj[v][w].v, d[Adj[v][w].v])</span></span>;</span><br><span class="line">q.<span class="built_in">push</span>(K);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="function">Node <span class="title">temp</span><span class="params">(y,z)</span></span>;</span><br><span class="line">Adj[x].<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;d[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd算法（解决全源最短路径）"><a href="#Floyd算法（解决全源最短路径）" class="headerlink" title="Floyd算法（解决全源最短路径）"></a>Floyd算法（解决全源最短路径）</h3><p>该算法用于求任意两点之间的最短路径，也可以来求解一个点是否能到达另一个点。dis[][]数组用于存图。算法核心在于中转站的选择，意为在前v个中转站被允许参与中转的情况下，任意两点可以到达的最短路径，枚举中转站的时候也可以用来判断该点是否位于最短路径当中。注意先初始化dis[][]为INF。</p><p>求路径</p><p>Floyd算法可以多开一个path的二位数组来存放中转站标号，只需要在dp的时候在下面多加一句path[u][w]&#x3D;v;即可。<br>在求路径的时候需要用到递归。限制条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dis[i][j];</span><br><span class="line">        path[i][j] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Floyd算法求任意两点最短路径长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>; w &lt;= n; ++w) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[u][w] &gt; dis[u][v] + dis[v][w]) &#123;</span><br><span class="line">                dis[u][w] = min(dis[u][w], dis[u][v] + dis[v][w]);</span><br><span class="line">                <span class="comment">//  path[u][w]=v;   //记录路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (paht[u][v] == <span class="number">-1</span>) &#123;    <span class="comment">//u与v之间已经没有任何中转站，二者已经直接相连了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = path[u][v]; <span class="comment">//中转站</span></span><br><span class="line">        <span class="built_in">printPath</span>(u, mid);   <span class="comment">//左递归打印u到中转站的路径</span></span><br><span class="line">        <span class="built_in">printPath</span>(mid, v);   <span class="comment">//有递归打印中转站到v的路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>Bellman-Ford算法使用于求解单源最短路，该算法可以允许负权值边的存在。Bellman-Ford算法算法思想为进行n次松弛操作，每一次松弛操作都枚举每一条边，对该边的两端顶点路径长度进行修改。以此求出最短路径。时间复杂度为O（nm），其中n为顶点数，m为边数。</p><h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><p>SPFA（Shortest Path Faster Algorithm）算法，是Bellman-Ford算法的队列优化版，时间复杂度较为玄学，理论上讲SPFA可以对Bellman-Ford进行常数级别的优化，但是在算法竞赛当中可能出现卡SPFA时间复杂度使其时间复杂度退化为O（nm）的情况，对于不存在负权值边的图来讲，Dijkstra算法在优先队列优化过后效果稳定且时间复杂度优秀，优先选用Dijkstra。但是对于存在负权值边的图来讲，Dijkstra算法会失效，所以还得使用SPFA。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, a, b, w;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">vertex = v, weight = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vertex, weight;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; G[maxn];   <span class="comment">//邻接链表存图</span></span><br><span class="line"><span class="type">int</span> dis[maxn];  <span class="comment">//记录最终的距离数组</span></span><br><span class="line"><span class="type">bool</span> mark[maxn];<span class="comment">//记录顶点是否存在于队列之中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化距离为无穷大，原点为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">dis[start] = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">mark[start] = <span class="number">1</span>;<span class="comment">//该顶点已经入队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> v = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">mark[v] = <span class="number">0</span>;<span class="comment">//该顶点出队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G[v].<span class="built_in">size</span>(); ++w) &#123;  <span class="comment">//松弛</span></span><br><span class="line"><span class="keyword">if</span> (dis[G[v][w].vertex] &gt; dis[v] + G[v][w].weight) &#123;</span><br><span class="line">dis[G[v][w].vertex] = dis[v] + G[v][w].weight;</span><br><span class="line"><span class="keyword">if</span> (!mark[G[v][w].vertex]) &#123;<span class="comment">//可以松弛并且该顶点没有在队列里面</span></span><br><span class="line">mark[G[v][w].vertex] = <span class="number">1</span>;<span class="comment">//顶点入队并且进行mark的记录</span></span><br><span class="line">q.<span class="built_in">push</span>(G[v][w].vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5.最小生成树"></a>5.最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">        vertex = v, weight = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> vertex, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node n1, node n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1.weight &gt; n2.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, m, a, b, w, ans;</span><br><span class="line"><span class="type">bool</span> mark[maxn];<span class="comment">//标记数组</span></span><br><span class="line"><span class="type">int</span> dis[maxn];  <span class="comment">//存与顶点相连的边的长度</span></span><br><span class="line">vector&lt;node&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; q;</span><br><span class="line">    <span class="function">node <span class="title">N</span><span class="params">(start, <span class="number">0</span>)</span></span>;</span><br><span class="line">    q.<span class="built_in">push</span>(N);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node M = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span> (mark[M.vertex]) <span class="keyword">continue</span>;    <span class="comment">//已访问过的节点不需要再访问</span></span><br><span class="line">        <span class="keyword">if</span> (dis[M.vertex] == INF) <span class="keyword">break</span>;   <span class="comment">//图不连通</span></span><br><span class="line">        mark[M.vertex] = <span class="number">1</span>;   <span class="comment">//标记已访问</span></span><br><span class="line">        <span class="type">int</span> v = M.vertex;</span><br><span class="line">        <span class="comment">//松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">//需要特判是否重复选择</span></span><br><span class="line">            <span class="keyword">if</span> (dis[G[v][i].vertex] &gt; G[v][i].weight &amp;&amp; !mark[G[v][i].vertex]) &#123;</span><br><span class="line">                dis[G[v][i].vertex] = G[v][i].weight;</span><br><span class="line">                <span class="function">node <span class="title">P</span><span class="params">(G[v][i].vertex, G[v][i].weight)</span></span>;</span><br><span class="line">                q.<span class="built_in">push</span>(P);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;    <span class="comment">//创建边结构体</span></span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u, <span class="type">int</span> _v, <span class="type">int</span> _w) &#123;</span><br><span class="line">        u = _u, v = _v, w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge e1, edge e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.w &lt; e2.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, a, b, w, cnt, ans;</span><br><span class="line">vector&lt;edge&gt; E; <span class="comment">//存储图的所有边</span></span><br><span class="line"><span class="type">int</span> father[maxn];   <span class="comment">//并查集</span></span><br><span class="line"><span class="type">int</span> _find(<span class="type">int</span> s) &#123; <span class="comment">//查</span></span><br><span class="line">    <span class="keyword">while</span> (father[s] != s) s = father[s];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> s1, <span class="type">int</span> s2)</span> </span>&#123;    <span class="comment">//并</span></span><br><span class="line">    <span class="type">int</span> f1 = _find(s1), f2 = _find(s2);</span><br><span class="line">    father[<span class="built_in">max</span>(f1, f2)] = father[<span class="built_in">min</span>(f1, f2)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) father[i] = i;    <span class="comment">//初始化每一条边为自己的父亲</span></span><br><span class="line">    <span class="comment">//按照每一条边的权重排序</span></span><br><span class="line">    <span class="built_in">sort</span>(E.<span class="built_in">begin</span>(), E.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//枚举每一条边</span></span><br><span class="line">        <span class="type">int</span> _u = E[i].u, _v = E[i].v, _w = E[i].w;</span><br><span class="line">        <span class="keyword">if</span> (_find(_u) != _find(_v)) &#123;</span><br><span class="line">            cnt++;    <span class="comment">//计数器，如果最终cnt!=n-1则图不连通</span></span><br><span class="line">            ans += _w;</span><br><span class="line">            <span class="built_in">merge</span>(_u, _v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//全部的边找到了就截断函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、Tarjan算法"><a href="#6、Tarjan算法" class="headerlink" title="6、Tarjan算法"></a>6、Tarjan算法</h2><h3 id="强连通分量（Strongly-Connected-Components）"><a href="#强连通分量（Strongly-Connected-Components）" class="headerlink" title="强连通分量（Strongly Connected Components）"></a>强连通分量（Strongly Connected Components）</h3><ul><li><p>若有向图中有两个点 i 与 j 可以相互到达，则称这两个点强连通，如果图中任意两个点都强连通，则该图称为强连通图。任意一个点自己和自己是强连通的。</p></li><li><p>非强连通有向图的极大强连通子图称为该图的强连通分量。</p></li><li><p>根据定义，两个点一定是强连通的，当且仅当它们在同一个环内。环上所有的点都互相强连通。</p></li></ul><p><strong>算法思路</strong></p><p>该算法有两个数组比较重要，第一个是时间戳数组dfn[]，该数组是用来记录对应节点第一次被访问的顺序。另一个是追溯值数组low[]，该数组表示了从对应节点出发，所能够访问到的最早时间戳，以便方便我们进行强连通分量的判断。</p><p>算法分三步：</p><ol><li>入：指从 x 节点发起Tarjan算法时，记录 x 对应的时间戳，并将 x 入栈。</li><li>回：我们对 x 发起Tarjan算法，对 x 的子节点 y 进行遍历，分以下三种情况：<ul><li>如果 y 还未被访问，则继续对 y 进行深搜。回溯到 x 的时候，我们需要利用 y 的low值来更新 x 的low值。</li><li>如果 y 已经被访问并且 y 在栈中，说明了 y 是 x 的祖先节点或者左子树节点，这个时候我们直接利用 y 的dfn值来更新 x 的low值。</li><li>如果 y 已经访问并且不在栈中，表示 y 已经是属于另一个强连通分量，不需要对其进行其他处理了。</li></ul></li><li>离：在处理完 x 之后，判断 x 是否为一个强连通分量的入口，如果是，则出栈，并且记录相对应的强连通分量。</li><li>根据算法过程容易注意到，因为回溯，所以越往后搜索到的点强连通分量编号越靠前。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a, b, ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];<span class="comment">//邻接表存图</span></span><br><span class="line"><span class="type">bool</span> instk[maxn];<span class="comment">//判断元素是否在栈中</span></span><br><span class="line"><span class="type">int</span> stk[maxn], top;<span class="comment">//stk为手写栈，top为栈顶指针</span></span><br><span class="line"><span class="type">int</span> dfn[maxn], low[maxn], tot;<span class="comment">//时间戳，low值，对应的标记</span></span><br><span class="line"><span class="type">int</span> scc[maxn], siz[maxn], cnt;<span class="comment">//对应的节点属于哪一个强连通分量，对应的强连通分量的大小，强连通分量的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//入</span></span><br><span class="line">dfn[x] = low[x] = ++tot;<span class="comment">//初始化时间戳和追溯值</span></span><br><span class="line">stk[++top] = x, instk[x] = <span class="number">1</span>;<span class="comment">//元素入栈</span></span><br><span class="line"><span class="comment">//回</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="type">int</span> y = G[x][i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[y]) &#123;<span class="comment">//子节点没被访问，访问子节点</span></span><br><span class="line"><span class="built_in">Tarjan</span>(y);</span><br><span class="line">low[x] = <span class="built_in">min</span>(low[x], low[y]);<span class="comment">//利用子节点的追溯值来更新自己的追溯值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (instk[y]) &#123;<span class="comment">//子节点已经在栈中</span></span><br><span class="line">low[x] = <span class="built_in">min</span>(low[x], dfn[y]);<span class="comment">//子节点的时间戳来更新自己的追溯值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离</span></span><br><span class="line"><span class="keyword">if</span> (dfn[x] == low[x]) &#123;<span class="comment">//如果该节点是某一个SCC的入口，则对这个SCC进行处理</span></span><br><span class="line"><span class="type">int</span> tmp; ++cnt;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">tmp = stk[top--]; instk[tmp] = <span class="number">0</span>;<span class="comment">//取栈顶元素，出栈</span></span><br><span class="line">scc[tmp] = cnt;<span class="comment">//该顶点属于第cnt个SCC</span></span><br><span class="line">++siz[cnt];<span class="comment">//第cnt个SCC的大小加1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (tmp != x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i);<span class="comment">//如果这个顶点没被访问过，就从它开始发起Tarjan算法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (siz[i] &gt; <span class="number">1</span>) ++ans;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tarjan算法缩点"><a href="#Tarjan算法缩点" class="headerlink" title="Tarjan算法缩点"></a>Tarjan算法缩点</h3><p>Tarjan算法的缩点一般是在利用Tarjan算法求出SCC之后进行的操作，通常是对一个节点 i 访问它的子节点 j ，而后判断两个节点是否属于同一个SCC，如果不属于同一个SCC，则记录相应的入度出度，或者直接建新图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩点处理出度入度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (scc[i] != scc[G[i][j]]) &#123;</span><br><span class="line">din[scc[G[i][j]]]++;<span class="comment">//入度++</span></span><br><span class="line">dout[scc[i]]++;<span class="comment">//出度++</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩点建新图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (scc[i] != scc[G[i][j]])</span><br><span class="line">new_G[scc[i]].<span class="built_in">push_back</span>(scc[G[i][j]]);<span class="comment">//建新图</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、Hierholzer算法"><a href="#7、Hierholzer算法" class="headerlink" title="7、Hierholzer算法"></a>7、Hierholzer算法</h2><p>又称插入回路法，用于求解欧拉路和欧拉路径。</p><p>时间复杂度O（n+m），空间复杂度O（n），n为顶点数，m为边数。</p><p>求解欧拉路的时候需要提前判明该图是否存在欧拉路。判定条件如下：</p><p>有向图：</p><ul><li>欧拉回路：所有顶点出度入度一致。</li><li>欧拉路径：恰好有一个点的出度比入度多1（起点），恰好有一个点的入度比出度多1（终点）。</li></ul><p>无向图：</p><ul><li>欧拉回路：所有顶点的度数为偶数。</li><li>欧拉路径：恰好有两个顶点的度数为奇数。</li></ul><h3 id="有向图欧拉路"><a href="#有向图欧拉路" class="headerlink" title="有向图欧拉路"></a>有向图欧拉路</h3><p>接下来以邻接链表有向图的欧拉路求解算法进行演示（字典序最小的欧拉路）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> n, m, u, v, start = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">//判定图是否满足要求，默认满足欧拉图要求</span></span><br><span class="line"><span class="type">int</span> indegree[maxn], outdegree[maxn]; <span class="comment">//入度出度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];    <span class="comment">//邻接链表存图</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; ans; <span class="comment">//存路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge_path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;  <span class="comment">//出度比入度多的顶点个数，入度比出度多的顶点个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == outdegree[i]) <span class="keyword">continue</span>; <span class="comment">//出度入度相等</span></span><br><span class="line">        <span class="keyword">if</span> (indegree[i] + <span class="number">1</span> == outdegree[i]) &#123;   <span class="comment">//起点</span></span><br><span class="line">            cnt1++;</span><br><span class="line">            start = i;    <span class="comment">//记录起点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (indegree[i] == outdegree[i] + <span class="number">1</span>) cnt2++;    <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//其他条件不满足欧拉图要求</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!((cnt1 == <span class="number">1</span> &amp;&amp; cnt2 == <span class="number">1</span>) || (cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span>))) flag = <span class="literal">false</span>;   <span class="comment">//欧拉路径和欧拉回路情况判定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = G[s].<span class="built_in">begin</span>(); it != G[s].<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="type">int</span> next = *it;   <span class="comment">//取点</span></span><br><span class="line">        it = G[s].<span class="built_in">erase</span>(it);  <span class="comment">//删边</span></span><br><span class="line">        <span class="built_in">dfs</span>(next);  <span class="comment">//深搜继续</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push</span>(s);    <span class="comment">//无法再搜索了，此时记录节点，回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//点数和边数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);  <span class="comment">//建图</span></span><br><span class="line">        ++outdegree[u]; <span class="comment">//记录出度</span></span><br><span class="line">        ++indegree[v];  <span class="comment">//记录入度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">juede_path</span>();   <span class="comment">//判定该图是否为欧拉图</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> temp = ans.<span class="built_in">top</span>();</span><br><span class="line">        cout &lt;&lt; temp &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        ans.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无向图欧拉路"><a href="#无向图欧拉路" class="headerlink" title="无向图欧拉路"></a>无向图欧拉路</h3><p>无向图欧拉路，使用了并查集特判图是否连通。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="type">int</span> n, m, a, b, start = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">//默认满足欧拉图要求</span></span><br><span class="line"><span class="type">int</span> degree[maxn], father[maxn];    <span class="comment">//顶点的度，father为并查集，用于判断图是否连通</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;    <span class="comment">//边结构体，用于记录无向边的信息</span></span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u, <span class="type">int</span> _v) &#123; u = _u, v = _v; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(edge e1)<span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == e1.u) <span class="keyword">return</span> v &lt; e1.v;</span><br><span class="line">        <span class="keyword">return</span> u &lt; e1.u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;edge&gt; E;    <span class="comment">//储存边的信息</span></span><br><span class="line"><span class="type">int</span> _find(<span class="type">int</span> s) &#123;    <span class="comment">//查</span></span><br><span class="line">    <span class="keyword">while</span> (father[s] != s) s = father[s];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _merge(<span class="type">int</span> s1, <span class="type">int</span> s2) &#123;        <span class="comment">//并</span></span><br><span class="line">    <span class="type">int</span> f1 = _find(s1), f2 = _find(s2);</span><br><span class="line">    father[<span class="built_in">max</span>(f1, f2)] = father[<span class="built_in">min</span>(f1, f2)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge_path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;    <span class="comment">//初始化并查集数组</span></span><br><span class="line">        <span class="keyword">if</span> (degree[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;  <span class="comment">//度数为奇数的点</span></span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;edge&gt;::iterator it = E.<span class="built_in">begin</span>(); it != E.<span class="built_in">end</span>(); it++) &#123;    <span class="comment">//并</span></span><br><span class="line">        edge tmp = *it;</span><br><span class="line">        _merge(tmp.u, tmp.v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> f = _find(i);</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="number">1</span>) &#123;    <span class="comment">//判断图不连通</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(cnt == <span class="number">0</span> || cnt == <span class="number">2</span>)) flag = <span class="literal">false</span>;    <span class="comment">//度数有除了0和2以外的，不是欧拉图</span></span><br><span class="line"><span class="comment">//    if (cnt == 2 &amp;&amp; !(degree[1] &amp; 1)) flag = false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[start].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        edge _find(<span class="built_in">min</span>(start, G[start][i]), <span class="built_in">max</span>(start, G[start][i]));</span><br><span class="line">        set&lt;edge&gt;::iterator it = E.<span class="built_in">find</span>(_find);</span><br><span class="line">        <span class="keyword">if</span> (it != E.<span class="built_in">end</span>()) &#123;   <span class="comment">//边存在</span></span><br><span class="line">            E.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="built_in">dfs</span>(G[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push</span>(start);    <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        E.<span class="built_in">insert</span>(<span class="built_in">edge</span>(<span class="built_in">min</span>(a, b), <span class="built_in">max</span>(a, b)));    <span class="comment">//储存边</span></span><br><span class="line">        degree[a]++;</span><br><span class="line">        degree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">judge_path</span>();</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;    <span class="comment">//无法画出欧拉路</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//排序，保证路径的字典序最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(start);</span><br><span class="line">        <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> temp = ans.<span class="built_in">top</span>();</span><br><span class="line">            cout &lt;&lt; temp &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            ans.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学问题</title>
      <link href="/2024/02/03/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2024/02/03/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>快读</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>); ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一、高精度"><a href="#一、高精度" class="headerlink" title="一、高精度"></a>一、高精度</h2><h3 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//高精度加法计算</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2;</span><br><span class="line">    cin &gt;&gt; str1;<span class="comment">//输入第一个数</span></span><br><span class="line">    cin &gt;&gt; str2;<span class="comment">//输入第二个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">size</span>(); i ++)<span class="comment">//逆序输入</span></span><br><span class="line">        a[str1.<span class="built_in">size</span>()<span class="number">-1</span> - i] = str1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str2.<span class="built_in">size</span>(); i ++)<span class="comment">//逆序输入</span></span><br><span class="line">        b[str2.<span class="built_in">size</span>()<span class="number">-1</span> - i] = str2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        c[i+<span class="number">1</span>] += c[i] / <span class="number">10</span>;<span class="comment">//若大于10，进1</span></span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[len<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>)</span><br><span class="line">        len -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">        cout &lt;&lt; c[len<span class="number">-1</span>-i];<span class="comment">//逆序输出数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;    <span class="comment">//输入两个数字</span></span><br><span class="line"><span class="comment">//判断相减之后是否为负数</span></span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() || s1.<span class="built_in">size</span>() == s2.<span class="built_in">size</span>() &amp;&amp; s1 &lt; s2) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(s1, s2);    <span class="comment">//交换s1和s2，保证使用s1-s2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">max</span>(s1.<span class="built_in">size</span>(), s2.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    a[s1.<span class="built_in">size</span>() - <span class="number">1</span> - i] = s1[i] - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    b[s2.<span class="built_in">size</span>() - <span class="number">1</span> - i] = s2[i] - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理相减</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; b[i]) &#123; <span class="comment">//不够减向上借一位</span></span><br><span class="line">        a[i + <span class="number">1</span>]--;</span><br><span class="line">        a[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[i] = a[i] - b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除前导0</span></span><br><span class="line"><span class="keyword">while</span> (c[len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;   <span class="comment">//逆序输出</span></span><br><span class="line">    cout &lt;&lt; c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-高精度乘低精度"><a href="#3-高精度乘低精度" class="headerlink" title="3.高精度乘低精度"></a>3.高精度乘低精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N],b,c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;b;<span class="comment">//输入大数字 小数字</span></span><br><span class="line"><span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[len<span class="number">-1</span>-i]=s[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理相乘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]+=a[i]*b;</span><br><span class="line">c[i+<span class="number">1</span>]+=c[i]/<span class="number">10</span>;</span><br><span class="line">c[i]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求出数组最终长度</span></span><br><span class="line"><span class="keyword">while</span>(c[len]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c[len+<span class="number">1</span>]+=c[len]/<span class="number">10</span>;</span><br><span class="line">c[len]%=<span class="number">10</span>;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除前导0</span></span><br><span class="line"><span class="keyword">while</span>(c[len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;len&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//逆序输出</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-高精度乘高精度"><a href="#4-高精度乘高精度" class="headerlink" title="4.高精度乘高精度"></a>4.高精度乘高精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[s1.<span class="built_in">size</span>()<span class="number">-1</span>-i]=s1[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">b[s2.<span class="built_in">size</span>()<span class="number">-1</span>-i]=s2[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//逆序输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理相乘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s2.<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k=i+j;</span><br><span class="line">c[k]+=a[i]*b[j];</span><br><span class="line">c[k+<span class="number">1</span>]+=c[k]/<span class="number">10</span>;</span><br><span class="line">c[k]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断进位进到哪里，两个数相乘，位数最多是x+y位，所以从x+y+1位那里开始判断</span></span><br><span class="line"><span class="type">int</span> len=s1.<span class="built_in">size</span>()+s2.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(c[len<span class="number">-1</span>]&gt;<span class="number">0</span>)len++;</span><br><span class="line"><span class="comment">//删除前导0</span></span><br><span class="line"><span class="keyword">while</span>(c[len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;len&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;c[i];<span class="comment">//逆序输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-低精度除法高精商"><a href="#5-低精度除法高精商" class="headerlink" title="5.低精度除法高精商"></a>5.低精度除法高精商</h3><p>a除以b，要求输出小数点后n位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b, n, c[<span class="number">100</span>];</span><br><span class="line">c[<span class="number">0</span>] = a / b;   <span class="comment">//整数部分</span></span><br><span class="line"><span class="type">int</span> t = a % b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    c[i] = t * <span class="number">10</span> / b;</span><br><span class="line">    t = t * <span class="number">10</span> - c[i] * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先输出小数点前的数字以及小数点</span></span><br><span class="line">cout &lt;&lt; c[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="comment">//然后再来输出小数点后面的数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高精度除法低精度商"><a href="#6-高精度除法低精度商" class="headerlink" title="6.高精度除法低精度商"></a>6.高精度除法低精度商</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除数用s1存放，被除数用int b存放，余数用int t存放，商用s2存放</span></span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="type">int</span> b, t, x;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; b;</span><br><span class="line"><span class="comment">//高精度除法用正序转存s1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    a[i] = s1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//商暂时存在数组c中，长度存在int x中</span></span><br><span class="line">t = x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//代入计算的时候要注意余数t的参与</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    c[i] = (t * <span class="number">10</span> + a[i]) / b; <span class="comment">//记得加上上一个数作除法之后留下的余数</span></span><br><span class="line">    t = (t * <span class="number">10</span> + a[i]) % b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理前导0</span></span><br><span class="line"><span class="keyword">while</span> (c[x] == <span class="number">0</span> &amp;&amp; x &lt; s1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将商存到s2中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    s2 += c[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出商和余数</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t;</span><br></pre></td></tr></table></figure><h2 id="二、最大公约数与最小公倍数"><a href="#二、最大公约数与最小公倍数" class="headerlink" title="二、最大公约数与最小公倍数"></a>二、最大公约数与最小公倍数</h2><p>辗转相除法（欧几里得算法）最大公约数</p><p>时间复杂度为O（logb）</p><p>定理</p><p>当a与b都为正整数且a&gt;b时，记gcd(a,b)为a与b的最大公约数，则有gcd（a,b）&#x3D;gcd（b, a mod b）</p><p>证明</p><p>a可以表示成 a &#x3D; kb + r（a，b，k，r皆为正整数，且r不为0）</p><p>假设d是a，b的一个公约数，则有d|a，d|b，即a和b都可以被d整除。（x|y意为kx &#x3D; y，k为正整数）</p><p>而r &#x3D; a - kb，两边同时除以d，r&#x2F;d &#x3D; a&#x2F;d - kb&#x2F;d，由等式右边可知m &#x3D; r&#x2F;d为整数，因此d|r</p><p>因此d也是b，a mod b的公约数</p><p>故（a,b）与（b, a mod b）的公约数相等，则其最大公约数也相等，得证。</p><p>举例</p><p>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>1997 &#x2F; 615 &#x3D; 3 （余 152）<br>615 &#x2F; 152 &#x3D; 4（余7）<br>152 &#x2F; 7 &#x3D; 21（余5）<br>7 &#x2F; 5 &#x3D; 1 （余2）<br>5 &#x2F; 2 &#x3D; 2 （余1）<br>2 &#x2F; 1 &#x3D; 2 （余0）<br>至此，最大公约数为1。</p><h3 id="1-递归版"><a href="#1-递归版" class="headerlink" title="1.递归版"></a>1.递归版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-循环版"><a href="#2-循环版" class="headerlink" title="2.循环版"></a>2.循环版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>(a % b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       c = a % b;</span><br><span class="line">       a = b;</span><br><span class="line">       b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-内置函数"><a href="#3-内置函数" class="headerlink" title="3.内置函数"></a>3.内置函数</h3><p>C++可以使用内置函数__gcd（a,b）来求两数的最大公约数，使用时需包含头文件algorithm。</p><h3 id="4-求最大公倍数"><a href="#4-求最大公倍数" class="headerlink" title="4.求最大公倍数"></a>4.求最大公倍数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、素数筛法"><a href="#三、素数筛法" class="headerlink" title="三、素数筛法"></a>三、素数筛法</h2><h3 id="1-朴素筛法"><a href="#1-朴素筛法" class="headerlink" title="1.朴素筛法"></a>1.朴素筛法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-埃氏（Eratosthenes）筛法"><a href="#2-埃氏（Eratosthenes）筛法" class="headerlink" title="2.埃氏（Eratosthenes）筛法"></a>2.埃氏（Eratosthenes）筛法</h3><p>假设要筛2-n内的素数，则先将2的倍数从里面剔除，再将3的倍数从里面剔除，以此类推……（小学课本里面就已经记录了这种素数筛法，<del>这下我连小学生都不如了。。</del>）时间复杂度为O（nloglogn），已经非常接近线性了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//素数表获取</span></span><br><span class="line"><span class="comment">//埃式筛法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn],pnum=<span class="number">0</span>;<span class="comment">//数组来记录素数元素，pnum来记录素数个数</span></span><br><span class="line"><span class="type">bool</span> p[maxn];<span class="comment">//素数判断 false 则说明为素数，否则不为素数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">prime[pnum++]=i;<span class="comment">//记录素数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;maxn;j+=i)<span class="comment">//将素数的倍数标记为非素数</span></span><br><span class="line">&#123;</span><br><span class="line">p[j]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find_prime</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-欧拉（Euler）筛法"><a href="#3-欧拉（Euler）筛法" class="headerlink" title="3.欧拉（Euler）筛法"></a>3.欧拉（Euler）筛法</h3><p>欧拉筛法是埃氏筛法的改进，埃氏筛法终究会出现一个数被多个数筛掉的情况。例如因为120 &#x3D; 2^3 x 3 x 5，因为2，3，5是120的质因子，所以120会被2筛一次，被3筛一次，被5筛一次，共3次。</p><p>而欧拉筛法保证了每一个合数都被其最小质因子筛去，保证不会重复筛除。故遍历一次就好，时间复杂度为O（n）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//欧拉筛法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">bool</span> p[N];<span class="comment">//素数判断 false为素数 </span></span><br><span class="line"><span class="type">int</span> prime[N],pnum=<span class="number">0</span>;<span class="comment">//数组记录素数元素，pnum记录素数个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">prime[pnum++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;pnum&amp;&amp;i*prime[j]&lt;=N;j++)<span class="comment">//防止数组越界</span></span><br><span class="line">&#123;</span><br><span class="line">p[i*prime[j]]=<span class="literal">true</span>;<span class="comment">//最小质因子筛合数</span></span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find_prime</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、分数计算"><a href="#四、分数计算" class="headerlink" title="四、分数计算"></a>四、分数计算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分数运算</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span><span class="comment">//分数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> up;<span class="comment">//分子</span></span><br><span class="line"><span class="type">int</span> down;<span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//约分</span></span><br><span class="line"><span class="function">Frac <span class="title">reduction</span><span class="params">(Frac result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(result.down&lt;<span class="number">0</span>)<span class="comment">//分母为负数，分子分母变相反数</span></span><br><span class="line">&#123;</span><br><span class="line">result.up=-result.up;<span class="comment">//符号位放在分母上</span></span><br><span class="line">     result.down=-result.down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(result.up==<span class="number">0</span>)<span class="comment">//分子为0</span></span><br><span class="line">&#123;</span><br><span class="line">result.down=<span class="number">1</span>;<span class="comment">//分母为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> d=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(result.up),<span class="built_in">abs</span>(result.down));<span class="comment">//约分</span></span><br><span class="line">result.up/=d;</span><br><span class="line">result.down/=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function">Frac <span class="title">multi</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.up;</span><br><span class="line">result.down=f1.down*f2.down;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="function">Frac <span class="title">divide</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.down;</span><br><span class="line">result.down=f1.down*f2.up;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function">Frac <span class="title">add</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.down+f1.down*f2.up;</span><br><span class="line">result.down=f1.down*f2.down;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function">Frac <span class="title">minu</span><span class="params">(Frac f1,Frac f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Frac result;</span><br><span class="line">result.up=f1.up*f2.down-f1.down*f2.up;</span><br><span class="line">result.down=f1.down*f2.down;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Frac r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">r=<span class="built_in">reduction</span>(r);</span><br><span class="line"><span class="keyword">if</span>(r.down==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r.up);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(r.up)&gt;r.down)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d/%d\n&quot;</span>,r.up/r.down,<span class="built_in">abs</span>(r.up)%r.down,r.down);<span class="comment">//假分数表示形式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>,r.up,r.down);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b,c,d;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">Frac f,e,r;</span><br><span class="line">f.up=a;e.up=c;</span><br><span class="line">f.down=b;e.down=d;</span><br><span class="line"><span class="built_in">show</span>(f);</span><br><span class="line"><span class="built_in">show</span>(e);</span><br><span class="line">r=<span class="built_in">add</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line">r=<span class="built_in">minu</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line">r=<span class="built_in">multi</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line">r=<span class="built_in">divide</span>(f,e);</span><br><span class="line"><span class="built_in">show</span>(r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、前缀和"><a href="#五、前缀和" class="headerlink" title="五、前缀和"></a>五、前缀和</h2><p>1.一维前缀和</p><p>dp[i]表示从下标1开始到下标i的一维数组元素之和，若计算区间[a,b]的数组元素之和，其中递推式sum&#x3D;dp[j]-dp[i-1].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> arr[N],dp[N];<span class="comment">//dp[i]表示从下标1开始到下标i的数组元素之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i]=dp[i<span class="number">-1</span>]+arr[i];<span class="comment">//计算前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.二维前缀和</p><p>s(i,j)表示从（1,1)开始到（i，j)位置的二维数组所有元素之和，其中递推式为s(i,j)+&#x3D;s(i-1,j)+s(i,j-1)-s(i-1,j-1),则从（a+1,b+1)到（c，d)的和为s[a,b]+s[c,d]-s[a,d]-s[b,c].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line"><span class="comment">//s[i][j]表示从arr[1][1]到arr[i][j]的和</span></span><br><span class="line"><span class="type">int</span> n,l,r,t,arr[<span class="number">605</span>][<span class="number">605</span>],count,sum[<span class="number">605</span>][<span class="number">605</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 16 1 6</span></span><br><span class="line"><span class="comment">0 1 2 3</span></span><br><span class="line"><span class="comment">4 5 6 7</span></span><br><span class="line"><span class="comment">8 9 10 11</span></span><br><span class="line"><span class="comment">12 13 14 15</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> sumval=<span class="number">0</span>;<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left=<span class="built_in">max</span>(<span class="number">1</span>,x-r),right=<span class="built_in">min</span>(n,x+r);<span class="comment">//左右边界</span></span><br><span class="line"><span class="type">int</span> down=<span class="built_in">max</span>(<span class="number">1</span>,y-r),up=<span class="built_in">min</span>(n,y+r);<span class="comment">//上下边界</span></span><br><span class="line">sumval = sum[right][up] - sum[right][down<span class="number">-1</span>] - sum[left<span class="number">-1</span>][up] + sum[left<span class="number">-1</span>][down<span class="number">-1</span>];</span><br><span class="line">num=(right-left+<span class="number">1</span>)*(up-down+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> ave=sumval*<span class="number">1.00</span>/num;</span><br><span class="line"><span class="keyword">if</span>(ave&lt;=t)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;arr[i][j];<span class="comment">//读入数据</span></span><br><span class="line">sum[i][j]=arr[i][j];</span><br><span class="line">sum[i][j] += sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] ;<span class="comment">//计算前缀和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">judge</span>(i,j))count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、差分"><a href="#六、差分" class="headerlink" title="六、差分"></a>六、差分</h2><p>差分是求前缀和的逆操作，对于原数组a[n],构造出一个b[n]数组中，使a[n]为b[n]的前缀和。一般用于快速对整个数组进行操作，比如将a数组中[l,r]部分的数据全部加上c.使用暴力的方法，则时间复杂度至少为O（n),而使用差分算法时间复杂度降低到O（1）.</p><p><strong>1.一维差分</strong><br>创建一数组b，使得数组a为数组b的前缀和，数组b为数组a的差分</p><p>构造方法：b[i] &#x3D; a[i] - a[i - 1]</p><p>此处使用了一个虚拟的构造方式(在数组一个位置加上一个数，那么在它的下一个位置减去这一数)</p><p>应用：对于a数组的任意区间[l, r]，令其加上一个数，而不改变其它值</p><p>b[l] +&#x3D; c, b[r + 1] -&#x3D; c</p><p>差分操作和前缀和一样数组下标都从1开始。</p><p>b[l]+c后，l后面的数组都会加c。r后面的数据也会被改变，要改回来就得b[r+1]-c.</p><p><strong>模板题如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">输入一个长度为 n 的整数序列。接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。</span><br><span class="line">请你输出进行完所有操作后的序列。输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。</span><br><span class="line">第二行包含 n 个整数，表示整数序列。</span><br><span class="line">接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。输出格式</span><br><span class="line">共一行，包含 n 个整数，表示最终序列。数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤l≤r≤n,</span><br><span class="line">−<span class="number">1000</span>≤c≤<span class="number">1000</span>,</span><br><span class="line">−<span class="number">1000</span>≤整数序列中元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )cin&gt;&gt;a[i];<span class="comment">//读入数据</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        b[j]=a[j]-a[j<span class="number">-1</span>];<span class="comment">//进行差分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        b[l]=b[l]+c;</span><br><span class="line">        b[r+<span class="number">1</span>]=b[r+<span class="number">1</span>]-c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        sum=sum+b[i];</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.二维差分</strong><br>直接得出公式<code>b[i][j] += c, b[i + 1][j] -= c, b[i][j + 1] -= c, b[i + 1][j + 1] += c</code><br>每次对b数组执行以上操作，等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=x1;i&lt;=x2;i++)</span><br><span class="line">  <span class="keyword">for</span>(int j=y1;j&lt;=y2;j++)</span><br><span class="line">    a[i][j]+=c;</span><br></pre></td></tr></table></figure><p><strong>模板题如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</span><br><span class="line">每个操作都要将选中的子矩阵中的每个元素的值加上 c。</span><br><span class="line">请你将进行完所有操作后的矩阵输出。输入格式</span><br><span class="line">第一行包含整数 n,m,q。</span><br><span class="line">接下来 n 行，每行包含 m 个整数，表示整数矩阵。</span><br><span class="line">接下来 q 行，每行包含 <span class="number">5</span> 个整数 x1,y1,x2,y2,c，表示一个操作。</span><br><span class="line">输出格式</span><br><span class="line">共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤x1≤x2≤n,</span><br><span class="line"><span class="number">1</span>≤y1≤y2≤m,</span><br><span class="line">−<span class="number">1000</span>≤c≤<span class="number">1000</span>,</span><br><span class="line">−<span class="number">1000</span>≤矩阵内元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);      <span class="comment">//构建差分数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//二维前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">           cout&lt;&lt;b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="七、扩展欧几里得算法"><a href="#七、扩展欧几里得算法" class="headerlink" title="七、扩展欧几里得算法"></a>七、扩展欧几里得算法</h2><p>给定两个整数a和b，求一组整数解（x,y)使得ax+by&#x3D;gcd(a,b)成立，其中gcd(a,b)表示a和b的最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">exgcd</span>(b,a%b,x,y);<span class="comment">//递归计算exgcd(b,a%b)</span></span><br><span class="line">    <span class="type">int</span> temp=x;<span class="comment">//存放x的值</span></span><br><span class="line">    x=y;<span class="comment">//更新x=y(old)</span></span><br><span class="line">    y=temp-a/b*y;  <span class="comment">//更新y=x(old)-a/b*y(old)</span></span><br><span class="line">    <span class="keyword">return</span> g;  <span class="comment">//g是gcd</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、进制转换"><a href="#八、进制转换" class="headerlink" title="八、进制转换"></a>八、进制转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//进制转化</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp1;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">char</span>&gt;mp2;</span><br><span class="line"><span class="type">int</span> num,temp;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">mp1[i+<span class="string">&#x27;0&#x27;</span>]=i;</span><br><span class="line">mp2[i]=i+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;F&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">mp1[i]=i-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">mp2[i-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d;<span class="comment">//初始进制</span></span><br><span class="line">cin&gt;&gt;d;</span><br><span class="line">string str;<span class="comment">//读入数据</span></span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//转化为10进制</span></span><br><span class="line">temp=temp*d+mp1[str[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;<span class="comment">//转化后的进制</span></span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">while</span>(temp)</span><br><span class="line">&#123;</span><br><span class="line">ans[num++]=mp2[temp%a];</span><br><span class="line">temp/=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、组合数求解"><a href="#九、组合数求解" class="headerlink" title="九、组合数求解"></a>九、组合数求解</h2><p>先上公式：<br>$$<br>C_n^m&#x3D;1(m&#x3D;0或m&#x3D;n)\<br>c_n^m&#x3D;c_{n-1}^m+c_{n-1}^{m-1}(n&gt;m&gt;0)<br>$$</p><p>所以，我们可以使用动态规划来求解组合数，直接上代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    dp[i][i] = dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到每一行的组合数都只需要用到上一行组合数的数值，所以可以进行<strong>状态压缩</strong>，注意倒序处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;    <span class="comment">//倒序处理</span></span><br><span class="line">        <span class="keyword">if</span> (j == i || j == <span class="number">0</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、蔡勒公式"><a href="#十、蔡勒公式" class="headerlink" title="十、蔡勒公式"></a>十、蔡勒公式</h2><p>用于知道年月日求对应是周几</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>$$<br>D&#x3D;[\frac{c}{4}]−2c+y+[\frac{y}{4}]+[\frac{3(m+1)}{4}]+d−1\</p><p>W&#x3D;D mod 7<br>$$</p><p>其中：</p><ul><li>W是星期数</li><li>D是辅助计算数（意为当前日期到原点日期一共经过多少天）</li><li>c是年份前两位</li><li>y是年份后两位</li><li>m是月份。m的取值范围是3至14，某年的1、2月看作是上一年的13、14月</li><li>d是日数</li><li>[]是取整运算（向下取整）</li><li>mod 是求余运算</li></ul><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>证明见<a href="https://www.cnblogs.com/faterazer/p/11393521.html">faterazer博客</a></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>计算 1994 年 12 月 13 日是星期几。显然 c &#x3D; 19，y &#x3D; 94，m &#x3D; 12，d &#x3D; 13，代入公式：<br>$$<br>D&#x3D;[\frac{19}{4}]−2*19+94+[\frac{94}{4}]+[\frac{3(12+1)}{4}]+13−1\</p><p>W&#x3D;128 mod 7<br>$$</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li>在计算机编程中，W 的计算结果有可能是负数。我们需要注意，数学中的求余运算和编程中的求余运算不是完全相同的，数学上余数不能是负数，而编程中余数可以是负数。因此，在计算机中 W 是负数时，我们需要进行修正。修正方法十分简单：让 W 加上一个足够大的 7 的整数倍，使其成为正数，得到的结果再对 7 取余即可。比如 -15，我可以让其加上 70，得到 55，再除以 7 余 6，通过余数可知这一天是星期六。</li><li>此公式只适用于格里高利历（也就是现在的公历）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
